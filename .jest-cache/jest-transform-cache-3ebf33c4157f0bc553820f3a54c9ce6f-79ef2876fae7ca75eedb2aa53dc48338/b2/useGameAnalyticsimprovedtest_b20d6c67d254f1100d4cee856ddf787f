4fb3910d0da7e3927e27411e099bb886
/**
 * Enhanced useGameAnalytics Hook Tests
 * 
 * This demonstrates improved testing patterns with:
 * - Consistent async/await handling
 * - Proper timeout management
 * - Comprehensive error scenarios
 * - Performance safeguards
 * - Better test isolation
 */ "use strict";
// Mock the analytics service
jest.mock('@/utils/analyticsService');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _useGameAnalytics = require("../useGameAnalytics");
const _analyticsService = require("../../utils/analyticsService");
const _SettingsContext = require("../../context/SettingsContext");
// Type the mocked service for better TypeScript support
const mockAnalyticsService = _analyticsService.analyticsService;
// Test constants
const TEST_TIMEOUTS = {
    FAST: 2000,
    MEDIUM: 5000,
    SLOW: 8000
};
const MOCK_DATA = {
    avatarId: '00000000-0000-0000-0000-000000000004',
    gameType: 'numbers',
    sessionId: 'session-123',
    recommendations: [
        {
            gameId: 'letters',
            reason: 'Try letters next!',
            priority: 8,
            estimatedDifficulty: 'beginner',
            learningObjectives: [],
            prerequisitesMet: true
        }
    ],
    metrics: {
        totalGamesPlayed: 1,
        averageSessionDuration: 60,
        overallCompletionRate: 1,
        skillLevelDistribution: {
            beginner: 1
        },
        subjectPreferences: {
            Mathematics: 1
        },
        learningVelocity: 1,
        engagementScore: 80
    }
};
describe('useGameAnalytics - Enhanced Tests', ()=>{
    // Test wrapper with providers
    const wrapper = ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_SettingsContext.SettingsProvider, {
            children: children
        });
    // Setup fresh mocks before each test
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup default successful mock implementations
        mockAnalyticsService.startGameSession.mockResolvedValue(MOCK_DATA.sessionId);
        mockAnalyticsService.trackEvent.mockResolvedValue(undefined);
        mockAnalyticsService.completeGameSession.mockResolvedValue(undefined);
        mockAnalyticsService.getLearningPathRecommendations.mockResolvedValue(MOCK_DATA.recommendations);
        mockAnalyticsService.getPerformanceMetrics.mockResolvedValue(MOCK_DATA.metrics);
    });
    // Cleanup after each test
    afterEach(()=>{
        jest.resetAllMocks();
        jest.useRealTimers();
    });
    describe('Session Management', ()=>{
        it('should start a session successfully with timeout protection', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Start session with timeout protection
            await (0, _react.act)(async ()=>{
                const startPromise = result.current.startSession();
                await Promise.race([
                    startPromise,
                    new Promise((_, reject)=>setTimeout(()=>reject(new Error('Session start timeout')), TEST_TIMEOUTS.FAST))
                ]);
            });
            // Verify session was started correctly
            expect(mockAnalyticsService.startGameSession).toHaveBeenCalledWith(MOCK_DATA.avatarId, MOCK_DATA.gameType, expect.any(Object), undefined);
            expect(result.current.sessionId).toBe(MOCK_DATA.sessionId);
            expect(result.current.isTracking).toBe(true);
        }, TEST_TIMEOUTS.MEDIUM);
        it('should handle session start failures gracefully', async ()=>{
            const testError = new Error('Session start failed');
            mockAnalyticsService.startGameSession.mockRejectedValue(testError);
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Capture console errors during test
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
            await (0, _react.act)(async ()=>{
                try {
                    await result.current.startSession();
                } catch (error) {
                // Expected to fail
                }
            });
            // Verify error handling
            expect(result.current.sessionId).toBeNull();
            expect(result.current.isTracking).toBe(false);
            consoleSpy.mockRestore();
        }, TEST_TIMEOUTS.FAST);
        it('should prevent multiple concurrent session starts', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Start multiple sessions concurrently
            await (0, _react.act)(async ()=>{
                const promises = [
                    result.current.startSession(),
                    result.current.startSession(),
                    result.current.startSession()
                ];
                await Promise.all(promises);
            });
            // Should only call the service once
            expect(mockAnalyticsService.startGameSession).toHaveBeenCalledTimes(1);
        }, TEST_TIMEOUTS.MEDIUM);
    });
    describe('Event Tracking', ()=>{
        it('should track question attempts with proper validation', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Start session first
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            // Wait for session to be established
            await (0, _react.waitFor)(()=>{
                expect(result.current.sessionId).toBe(MOCK_DATA.sessionId);
            }, {
                timeout: TEST_TIMEOUTS.FAST
            });
            // Track question attempt
            await (0, _react.act)(async ()=>{
                await result.current.trackQuestionAttempt(true, {
                    questionIndex: 0,
                    responseTime: 1500,
                    difficulty: 'easy'
                });
            });
            expect(mockAnalyticsService.trackEvent).toHaveBeenCalledWith(MOCK_DATA.sessionId, MOCK_DATA.avatarId, 'question_answer', expect.objectContaining({
                correct: true,
                questionIndex: 0,
                responseTime: 1500,
                difficulty: 'easy'
            }));
        }, TEST_TIMEOUTS.MEDIUM);
        it('should handle tracking failures without breaking the flow', async ()=>{
            const trackingError = new Error('Tracking failed');
            mockAnalyticsService.trackEvent.mockRejectedValue(trackingError);
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            // Suppress console error for this test
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
            await (0, _react.act)(async ()=>{
                // Should not throw even if tracking fails
                await expect(result.current.trackQuestionAttempt(true, {
                    questionIndex: 0
                })).resolves.not.toThrow();
            });
            consoleSpy.mockRestore();
        }, TEST_TIMEOUTS.FAST);
        it('should not track events without an active session', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Try to track without starting session
            await (0, _react.act)(async ()=>{
                await result.current.trackQuestionAttempt(true, {
                    questionIndex: 0
                });
            });
            expect(mockAnalyticsService.trackEvent).not.toHaveBeenCalled();
        }, TEST_TIMEOUTS.FAST);
    });
    describe('Session Completion', ()=>{
        it('should complete session and load analytics data', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Start session
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            // Wait for session establishment
            await (0, _react.waitFor)(()=>{
                expect(result.current.isTracking).toBe(true);
            }, {
                timeout: TEST_TIMEOUTS.FAST
            });
            // Complete session
            await (0, _react.act)(async ()=>{
                await result.current.completeSession(90);
            });
            // Verify completion call
            expect(mockAnalyticsService.completeGameSession).toHaveBeenCalledWith(MOCK_DATA.sessionId, 90, expect.any(Number), expect.any(Number));
            // Verify analytics data loading
            await (0, _react.waitFor)(()=>{
                expect(result.current.recommendations).toEqual(MOCK_DATA.recommendations);
                expect(result.current.performanceMetrics).toEqual(MOCK_DATA.metrics);
            }, {
                timeout: TEST_TIMEOUTS.MEDIUM
            });
        }, TEST_TIMEOUTS.SLOW);
        it('should handle completion failures gracefully', async ()=>{
            const completionError = new Error('Completion failed');
            mockAnalyticsService.completeGameSession.mockRejectedValue(completionError);
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
            await (0, _react.act)(async ()=>{
                await result.current.completeSession(90);
            });
            // Should still attempt to load analytics despite completion failure
            expect(mockAnalyticsService.getLearningPathRecommendations).toHaveBeenCalled();
            expect(mockAnalyticsService.getPerformanceMetrics).toHaveBeenCalled();
            consoleSpy.mockRestore();
        }, TEST_TIMEOUTS.MEDIUM);
    });
    describe('Performance & Edge Cases', ()=>{
        it('should complete operations within reasonable time limits', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            // Measure session start performance
            const startTime = performance.now();
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            const sessionStartTime = performance.now() - startTime;
            expect(sessionStartTime).toBeLessThan(1000); // Should complete within 1 second
            // Measure event tracking performance
            const trackStartTime = performance.now();
            await (0, _react.act)(async ()=>{
                await result.current.trackQuestionAttempt(true, {
                    questionIndex: 0
                });
            });
            const trackTime = performance.now() - trackStartTime;
            expect(trackTime).toBeLessThan(500); // Should complete within 500ms
        }, TEST_TIMEOUTS.MEDIUM);
        it('should handle rapid successive calls without issues', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            // Fire multiple tracking events rapidly
            await (0, _react.act)(async ()=>{
                const promises = Array.from({
                    length: 10
                }, (_, i)=>result.current.trackQuestionAttempt(i % 2 === 0, {
                        questionIndex: i
                    }));
                await Promise.all(promises);
            });
            // All events should be tracked
            expect(mockAnalyticsService.trackEvent).toHaveBeenCalledTimes(10);
        }, TEST_TIMEOUTS.MEDIUM);
        it('should cleanup properly on unmount', async ()=>{
            const { result, unmount } = (0, _react.renderHook)(()=>(0, _useGameAnalytics.useGameAnalytics)({
                    gameType: MOCK_DATA.gameType,
                    avatarId: MOCK_DATA.avatarId,
                    autoTrack: false
                }), {
                wrapper
            });
            await (0, _react.act)(async ()=>{
                await result.current.startSession();
            });
            // Unmount component
            unmount();
            // No memory leaks or hanging promises should remain
            expect(result.current.isTracking).toBe(true); // State preserved until cleanup
        }, TEST_TIMEOUTS.FAST);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxQcm9qZWN0c1xcZmFtaWx5LW9yaWVudGVkXFxzcmNcXGhvb2tzXFxfX3Rlc3RzX19cXHVzZUdhbWVBbmFseXRpY3MuaW1wcm92ZWQudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEVuaGFuY2VkIHVzZUdhbWVBbmFseXRpY3MgSG9vayBUZXN0c1xyXG4gKiBcclxuICogVGhpcyBkZW1vbnN0cmF0ZXMgaW1wcm92ZWQgdGVzdGluZyBwYXR0ZXJucyB3aXRoOlxyXG4gKiAtIENvbnNpc3RlbnQgYXN5bmMvYXdhaXQgaGFuZGxpbmdcclxuICogLSBQcm9wZXIgdGltZW91dCBtYW5hZ2VtZW50XHJcbiAqIC0gQ29tcHJlaGVuc2l2ZSBlcnJvciBzY2VuYXJpb3NcclxuICogLSBQZXJmb3JtYW5jZSBzYWZlZ3VhcmRzXHJcbiAqIC0gQmV0dGVyIHRlc3QgaXNvbGF0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgcmVuZGVySG9vaywgYWN0LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XHJcbmltcG9ydCB7IHVzZUdhbWVBbmFseXRpY3MgfSBmcm9tICcuLi91c2VHYW1lQW5hbHl0aWNzJztcclxuaW1wb3J0IHsgYW5hbHl0aWNzU2VydmljZSB9IGZyb20gJ0AvdXRpbHMvYW5hbHl0aWNzU2VydmljZSc7XHJcbmltcG9ydCB7IFNldHRpbmdzUHJvdmlkZXIgfSBmcm9tICdAL2NvbnRleHQvU2V0dGluZ3NDb250ZXh0JztcclxuXHJcbi8vIE1vY2sgdGhlIGFuYWx5dGljcyBzZXJ2aWNlXHJcbmplc3QubW9jaygnQC91dGlscy9hbmFseXRpY3NTZXJ2aWNlJyk7XHJcblxyXG4vLyBUeXBlIHRoZSBtb2NrZWQgc2VydmljZSBmb3IgYmV0dGVyIFR5cGVTY3JpcHQgc3VwcG9ydFxyXG5jb25zdCBtb2NrQW5hbHl0aWNzU2VydmljZSA9IGFuYWx5dGljc1NlcnZpY2UgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGFuYWx5dGljc1NlcnZpY2U+O1xyXG5cclxuLy8gVGVzdCBjb25zdGFudHNcclxuY29uc3QgVEVTVF9USU1FT1VUUyA9IHtcclxuICBGQVNUOiAyMDAwLFxyXG4gIE1FRElVTTogNTAwMCxcclxuICBTTE9XOiA4MDAwXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBNT0NLX0RBVEEgPSB7XHJcbiAgYXZhdGFySWQ6ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDQnLFxyXG4gIGdhbWVUeXBlOiAnbnVtYmVycycgYXMgY29uc3QsXHJcbiAgc2Vzc2lvbklkOiAnc2Vzc2lvbi0xMjMnLFxyXG4gIHJlY29tbWVuZGF0aW9uczogW1xyXG4gICAgeyBcclxuICAgICAgZ2FtZUlkOiAnbGV0dGVycycsIFxyXG4gICAgICByZWFzb246ICdUcnkgbGV0dGVycyBuZXh0IScsIFxyXG4gICAgICBwcmlvcml0eTogOCwgXHJcbiAgICAgIGVzdGltYXRlZERpZmZpY3VsdHk6ICdiZWdpbm5lcicsIFxyXG4gICAgICBsZWFybmluZ09iamVjdGl2ZXM6IFtdLCBcclxuICAgICAgcHJlcmVxdWlzaXRlc01ldDogdHJ1ZSBcclxuICAgIH1cclxuICBdLFxyXG4gIG1ldHJpY3M6IHtcclxuICAgIHRvdGFsR2FtZXNQbGF5ZWQ6IDEsXHJcbiAgICBhdmVyYWdlU2Vzc2lvbkR1cmF0aW9uOiA2MCxcclxuICAgIG92ZXJhbGxDb21wbGV0aW9uUmF0ZTogMSxcclxuICAgIHNraWxsTGV2ZWxEaXN0cmlidXRpb246IHsgYmVnaW5uZXI6IDEgfSxcclxuICAgIHN1YmplY3RQcmVmZXJlbmNlczogeyBNYXRoZW1hdGljczogMSB9LFxyXG4gICAgbGVhcm5pbmdWZWxvY2l0eTogMSxcclxuICAgIGVuZ2FnZW1lbnRTY29yZTogODBcclxuICB9XHJcbn0gYXMgY29uc3Q7XHJcblxyXG5kZXNjcmliZSgndXNlR2FtZUFuYWx5dGljcyAtIEVuaGFuY2VkIFRlc3RzJywgKCkgPT4ge1xyXG4gIC8vIFRlc3Qgd3JhcHBlciB3aXRoIHByb3ZpZGVyc1xyXG4gIGNvbnN0IHdyYXBwZXIgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkgPT4gKFxyXG4gICAgPFNldHRpbmdzUHJvdmlkZXI+e2NoaWxkcmVufTwvU2V0dGluZ3NQcm92aWRlcj5cclxuICApO1xyXG5cclxuICAvLyBTZXR1cCBmcmVzaCBtb2NrcyBiZWZvcmUgZWFjaCB0ZXN0XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgIFxyXG4gICAgLy8gU2V0dXAgZGVmYXVsdCBzdWNjZXNzZnVsIG1vY2sgaW1wbGVtZW50YXRpb25zXHJcbiAgICBtb2NrQW5hbHl0aWNzU2VydmljZS5zdGFydEdhbWVTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKE1PQ0tfREFUQS5zZXNzaW9uSWQpO1xyXG4gICAgbW9ja0FuYWx5dGljc1NlcnZpY2UudHJhY2tFdmVudC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG4gICAgbW9ja0FuYWx5dGljc1NlcnZpY2UuY29tcGxldGVHYW1lU2Vzc2lvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG4gICAgbW9ja0FuYWx5dGljc1NlcnZpY2UuZ2V0TGVhcm5pbmdQYXRoUmVjb21tZW5kYXRpb25zLm1vY2tSZXNvbHZlZFZhbHVlKE1PQ0tfREFUQS5yZWNvbW1lbmRhdGlvbnMpO1xyXG4gICAgbW9ja0FuYWx5dGljc1NlcnZpY2UuZ2V0UGVyZm9ybWFuY2VNZXRyaWNzLm1vY2tSZXNvbHZlZFZhbHVlKE1PQ0tfREFUQS5tZXRyaWNzKTtcclxuICB9KTtcclxuXHJcbiAgLy8gQ2xlYW51cCBhZnRlciBlYWNoIHRlc3RcclxuICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5yZXNldEFsbE1vY2tzKCk7XHJcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1Nlc3Npb24gTWFuYWdlbWVudCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgc3RhcnQgYSBzZXNzaW9uIHN1Y2Nlc3NmdWxseSB3aXRoIHRpbWVvdXQgcHJvdGVjdGlvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlR2FtZUFuYWx5dGljcyh7XHJcbiAgICAgICAgZ2FtZVR5cGU6IE1PQ0tfREFUQS5nYW1lVHlwZSxcclxuICAgICAgICBhdmF0YXJJZDogTU9DS19EQVRBLmF2YXRhcklkLFxyXG4gICAgICAgIGF1dG9UcmFjazogZmFsc2VcclxuICAgICAgfSksIHsgd3JhcHBlciB9KTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IHNlc3Npb24gd2l0aCB0aW1lb3V0IHByb3RlY3Rpb25cclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgICAgc3RhcnRQcm9taXNlLFxyXG4gICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignU2Vzc2lvbiBzdGFydCB0aW1lb3V0JykpLCBURVNUX1RJTUVPVVRTLkZBU1QpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IHNlc3Npb24gd2FzIHN0YXJ0ZWQgY29ycmVjdGx5XHJcbiAgICAgIGV4cGVjdChtb2NrQW5hbHl0aWNzU2VydmljZS5zdGFydEdhbWVTZXNzaW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBNT0NLX0RBVEEuYXZhdGFySWQsXHJcbiAgICAgICAgTU9DS19EQVRBLmdhbWVUeXBlLFxyXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KSxcclxuICAgICAgICB1bmRlZmluZWRcclxuICAgICAgKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlc3Npb25JZCkudG9CZShNT0NLX0RBVEEuc2Vzc2lvbklkKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzVHJhY2tpbmcpLnRvQmUodHJ1ZSk7XHJcbiAgICB9LCBURVNUX1RJTUVPVVRTLk1FRElVTSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2Vzc2lvbiBzdGFydCBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXN0RXJyb3IgPSBuZXcgRXJyb3IoJ1Nlc3Npb24gc3RhcnQgZmFpbGVkJyk7XHJcbiAgICAgIG1vY2tBbmFseXRpY3NTZXJ2aWNlLnN0YXJ0R2FtZVNlc3Npb24ubW9ja1JlamVjdGVkVmFsdWUodGVzdEVycm9yKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUdhbWVBbmFseXRpY3Moe1xyXG4gICAgICAgIGdhbWVUeXBlOiBNT0NLX0RBVEEuZ2FtZVR5cGUsXHJcbiAgICAgICAgYXZhdGFySWQ6IE1PQ0tfREFUQS5hdmF0YXJJZCxcclxuICAgICAgICBhdXRvVHJhY2s6IGZhbHNlXHJcbiAgICAgIH0pLCB7IHdyYXBwZXIgfSk7XHJcblxyXG4gICAgICAvLyBDYXB0dXJlIGNvbnNvbGUgZXJyb3JzIGR1cmluZyB0ZXN0XHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gRXhwZWN0ZWQgdG8gZmFpbFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBWZXJpZnkgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlc3Npb25JZCkudG9CZU51bGwoKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzVHJhY2tpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xyXG4gICAgfSwgVEVTVF9USU1FT1VUUy5GQVNUKTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgbXVsdGlwbGUgY29uY3VycmVudCBzZXNzaW9uIHN0YXJ0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlR2FtZUFuYWx5dGljcyh7XHJcbiAgICAgICAgZ2FtZVR5cGU6IE1PQ0tfREFUQS5nYW1lVHlwZSxcclxuICAgICAgICBhdmF0YXJJZDogTU9DS19EQVRBLmF2YXRhcklkLFxyXG4gICAgICAgIGF1dG9UcmFjazogZmFsc2VcclxuICAgICAgfSksIHsgd3JhcHBlciB9KTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IG11bHRpcGxlIHNlc3Npb25zIGNvbmN1cnJlbnRseVxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW1xyXG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3RhcnRTZXNzaW9uKCksXHJcbiAgICAgICAgICByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKSxcclxuICAgICAgICAgIHJlc3VsdC5jdXJyZW50LnN0YXJ0U2Vzc2lvbigpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIG9ubHkgY2FsbCB0aGUgc2VydmljZSBvbmNlXHJcbiAgICAgIGV4cGVjdChtb2NrQW5hbHl0aWNzU2VydmljZS5zdGFydEdhbWVTZXNzaW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICB9LCBURVNUX1RJTUVPVVRTLk1FRElVTSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdFdmVudCBUcmFja2luZycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgdHJhY2sgcXVlc3Rpb24gYXR0ZW1wdHMgd2l0aCBwcm9wZXIgdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlR2FtZUFuYWx5dGljcyh7XHJcbiAgICAgICAgZ2FtZVR5cGU6IE1PQ0tfREFUQS5nYW1lVHlwZSxcclxuICAgICAgICBhdmF0YXJJZDogTU9DS19EQVRBLmF2YXRhcklkLFxyXG4gICAgICAgIGF1dG9UcmFjazogZmFsc2VcclxuICAgICAgfSksIHsgd3JhcHBlciB9KTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IHNlc3Npb24gZmlyc3RcclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciBzZXNzaW9uIHRvIGJlIGVzdGFibGlzaGVkXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZXNzaW9uSWQpLnRvQmUoTU9DS19EQVRBLnNlc3Npb25JZCk7XHJcbiAgICAgIH0sIHsgdGltZW91dDogVEVTVF9USU1FT1VUUy5GQVNUIH0pO1xyXG5cclxuICAgICAgLy8gVHJhY2sgcXVlc3Rpb24gYXR0ZW1wdFxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnRyYWNrUXVlc3Rpb25BdHRlbXB0KHRydWUsIHsgXHJcbiAgICAgICAgICBxdWVzdGlvbkluZGV4OiAwLFxyXG4gICAgICAgICAgcmVzcG9uc2VUaW1lOiAxNTAwLFxyXG4gICAgICAgICAgZGlmZmljdWx0eTogJ2Vhc3knXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tBbmFseXRpY3NTZXJ2aWNlLnRyYWNrRXZlbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgIE1PQ0tfREFUQS5zZXNzaW9uSWQsXHJcbiAgICAgICAgTU9DS19EQVRBLmF2YXRhcklkLFxyXG4gICAgICAgICdxdWVzdGlvbl9hbnN3ZXInLFxyXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgXHJcbiAgICAgICAgICBjb3JyZWN0OiB0cnVlLCBcclxuICAgICAgICAgIHF1ZXN0aW9uSW5kZXg6IDAsXHJcbiAgICAgICAgICByZXNwb25zZVRpbWU6IDE1MDAsXHJcbiAgICAgICAgICBkaWZmaWN1bHR5OiAnZWFzeSdcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSwgVEVTVF9USU1FT1VUUy5NRURJVU0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRyYWNraW5nIGZhaWx1cmVzIHdpdGhvdXQgYnJlYWtpbmcgdGhlIGZsb3cnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYWNraW5nRXJyb3IgPSBuZXcgRXJyb3IoJ1RyYWNraW5nIGZhaWxlZCcpO1xyXG4gICAgICBtb2NrQW5hbHl0aWNzU2VydmljZS50cmFja0V2ZW50Lm1vY2tSZWplY3RlZFZhbHVlKHRyYWNraW5nRXJyb3IpO1xyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlR2FtZUFuYWx5dGljcyh7XHJcbiAgICAgICAgZ2FtZVR5cGU6IE1PQ0tfREFUQS5nYW1lVHlwZSxcclxuICAgICAgICBhdmF0YXJJZDogTU9DS19EQVRBLmF2YXRhcklkLFxyXG4gICAgICAgIGF1dG9UcmFjazogZmFsc2VcclxuICAgICAgfSksIHsgd3JhcHBlciB9KTtcclxuXHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuc3RhcnRTZXNzaW9uKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3VwcHJlc3MgY29uc29sZSBlcnJvciBmb3IgdGhpcyB0ZXN0XHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXZlbiBpZiB0cmFja2luZyBmYWlsc1xyXG4gICAgICAgIGF3YWl0IGV4cGVjdChyZXN1bHQuY3VycmVudC50cmFja1F1ZXN0aW9uQXR0ZW1wdCh0cnVlLCB7IHF1ZXN0aW9uSW5kZXg6IDAgfSkpXHJcbiAgICAgICAgICAucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XHJcbiAgICB9LCBURVNUX1RJTUVPVVRTLkZBU1QpO1xyXG5cclxuICAgIGl0KCdzaG91bGQgbm90IHRyYWNrIGV2ZW50cyB3aXRob3V0IGFuIGFjdGl2ZSBzZXNzaW9uJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VHYW1lQW5hbHl0aWNzKHtcclxuICAgICAgICBnYW1lVHlwZTogTU9DS19EQVRBLmdhbWVUeXBlLFxyXG4gICAgICAgIGF2YXRhcklkOiBNT0NLX0RBVEEuYXZhdGFySWQsXHJcbiAgICAgICAgYXV0b1RyYWNrOiBmYWxzZVxyXG4gICAgICB9KSwgeyB3cmFwcGVyIH0pO1xyXG5cclxuICAgICAgLy8gVHJ5IHRvIHRyYWNrIHdpdGhvdXQgc3RhcnRpbmcgc2Vzc2lvblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnRyYWNrUXVlc3Rpb25BdHRlbXB0KHRydWUsIHsgcXVlc3Rpb25JbmRleDogMCB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0FuYWx5dGljc1NlcnZpY2UudHJhY2tFdmVudCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgIH0sIFRFU1RfVElNRU9VVFMuRkFTVCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdTZXNzaW9uIENvbXBsZXRpb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNvbXBsZXRlIHNlc3Npb24gYW5kIGxvYWQgYW5hbHl0aWNzIGRhdGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUdhbWVBbmFseXRpY3Moe1xyXG4gICAgICAgIGdhbWVUeXBlOiBNT0NLX0RBVEEuZ2FtZVR5cGUsXHJcbiAgICAgICAgYXZhdGFySWQ6IE1PQ0tfREFUQS5hdmF0YXJJZCxcclxuICAgICAgICBhdXRvVHJhY2s6IGZhbHNlXHJcbiAgICAgIH0pLCB7IHdyYXBwZXIgfSk7XHJcblxyXG4gICAgICAvLyBTdGFydCBzZXNzaW9uXHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuc3RhcnRTZXNzaW9uKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gV2FpdCBmb3Igc2Vzc2lvbiBlc3RhYmxpc2htZW50XHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1RyYWNraW5nKS50b0JlKHRydWUpO1xyXG4gICAgICB9LCB7IHRpbWVvdXQ6IFRFU1RfVElNRU9VVFMuRkFTVCB9KTtcclxuXHJcbiAgICAgIC8vIENvbXBsZXRlIHNlc3Npb25cclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5jb21wbGV0ZVNlc3Npb24oOTApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSBjb21wbGV0aW9uIGNhbGxcclxuICAgICAgZXhwZWN0KG1vY2tBbmFseXRpY3NTZXJ2aWNlLmNvbXBsZXRlR2FtZVNlc3Npb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgIE1PQ0tfREFUQS5zZXNzaW9uSWQsXHJcbiAgICAgICAgOTAsXHJcbiAgICAgICAgZXhwZWN0LmFueShOdW1iZXIpLFxyXG4gICAgICAgIGV4cGVjdC5hbnkoTnVtYmVyKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IGFuYWx5dGljcyBkYXRhIGxvYWRpbmdcclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnJlY29tbWVuZGF0aW9ucykudG9FcXVhbChNT0NLX0RBVEEucmVjb21tZW5kYXRpb25zKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucGVyZm9ybWFuY2VNZXRyaWNzKS50b0VxdWFsKE1PQ0tfREFUQS5tZXRyaWNzKTtcclxuICAgICAgfSwgeyB0aW1lb3V0OiBURVNUX1RJTUVPVVRTLk1FRElVTSB9KTtcclxuICAgIH0sIFRFU1RfVElNRU9VVFMuU0xPVyk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29tcGxldGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb21wbGV0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBsZXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIG1vY2tBbmFseXRpY3NTZXJ2aWNlLmNvbXBsZXRlR2FtZVNlc3Npb24ubW9ja1JlamVjdGVkVmFsdWUoY29tcGxldGlvbkVycm9yKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUdhbWVBbmFseXRpY3Moe1xyXG4gICAgICAgIGdhbWVUeXBlOiBNT0NLX0RBVEEuZ2FtZVR5cGUsXHJcbiAgICAgICAgYXZhdGFySWQ6IE1PQ0tfREFUQS5hdmF0YXJJZCxcclxuICAgICAgICBhdXRvVHJhY2s6IGZhbHNlXHJcbiAgICAgIH0pLCB7IHdyYXBwZXIgfSk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnN0YXJ0U2Vzc2lvbigpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmNvbXBsZXRlU2Vzc2lvbig5MCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIHN0aWxsIGF0dGVtcHQgdG8gbG9hZCBhbmFseXRpY3MgZGVzcGl0ZSBjb21wbGV0aW9uIGZhaWx1cmVcclxuICAgICAgZXhwZWN0KG1vY2tBbmFseXRpY3NTZXJ2aWNlLmdldExlYXJuaW5nUGF0aFJlY29tbWVuZGF0aW9ucykudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICBleHBlY3QobW9ja0FuYWx5dGljc1NlcnZpY2UuZ2V0UGVyZm9ybWFuY2VNZXRyaWNzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcblxyXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XHJcbiAgICB9LCBURVNUX1RJTUVPVVRTLk1FRElVTSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSAmIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNvbXBsZXRlIG9wZXJhdGlvbnMgd2l0aGluIHJlYXNvbmFibGUgdGltZSBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUdhbWVBbmFseXRpY3Moe1xyXG4gICAgICAgIGdhbWVUeXBlOiBNT0NLX0RBVEEuZ2FtZVR5cGUsXHJcbiAgICAgICAgYXZhdGFySWQ6IE1PQ0tfREFUQS5hdmF0YXJJZCxcclxuICAgICAgICBhdXRvVHJhY2s6IGZhbHNlXHJcbiAgICAgIH0pLCB7IHdyYXBwZXIgfSk7XHJcblxyXG4gICAgICAvLyBNZWFzdXJlIHNlc3Npb24gc3RhcnQgcGVyZm9ybWFuY2VcclxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnN0YXJ0U2Vzc2lvbigpO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNlc3Npb25TdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgICAgZXhwZWN0KHNlc3Npb25TdGFydFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxIHNlY29uZFxyXG5cclxuICAgICAgLy8gTWVhc3VyZSBldmVudCB0cmFja2luZyBwZXJmb3JtYW5jZVxyXG4gICAgICBjb25zdCB0cmFja1N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC50cmFja1F1ZXN0aW9uQXR0ZW1wdCh0cnVlLCB7IHF1ZXN0aW9uSW5kZXg6IDAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdHJhY2tUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0cmFja1N0YXJ0VGltZTtcclxuICAgICAgZXhwZWN0KHRyYWNrVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNTAwbXNcclxuICAgIH0sIFRFU1RfVElNRU9VVFMuTUVESVVNKTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzdWNjZXNzaXZlIGNhbGxzIHdpdGhvdXQgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VHYW1lQW5hbHl0aWNzKHtcclxuICAgICAgICBnYW1lVHlwZTogTU9DS19EQVRBLmdhbWVUeXBlLFxyXG4gICAgICAgIGF2YXRhcklkOiBNT0NLX0RBVEEuYXZhdGFySWQsXHJcbiAgICAgICAgYXV0b1RyYWNrOiBmYWxzZVxyXG4gICAgICB9KSwgeyB3cmFwcGVyIH0pO1xyXG5cclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBGaXJlIG11bHRpcGxlIHRyYWNraW5nIGV2ZW50cyByYXBpZGx5XHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoXywgaSkgPT5cclxuICAgICAgICAgIHJlc3VsdC5jdXJyZW50LnRyYWNrUXVlc3Rpb25BdHRlbXB0KGkgJSAyID09PSAwLCB7IHF1ZXN0aW9uSW5kZXg6IGkgfSlcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBbGwgZXZlbnRzIHNob3VsZCBiZSB0cmFja2VkXHJcbiAgICAgIGV4cGVjdChtb2NrQW5hbHl0aWNzU2VydmljZS50cmFja0V2ZW50KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMTApO1xyXG4gICAgfSwgVEVTVF9USU1FT1VUUy5NRURJVU0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgY2xlYW51cCBwcm9wZXJseSBvbiB1bm1vdW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlc3VsdCwgdW5tb3VudCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VHYW1lQW5hbHl0aWNzKHtcclxuICAgICAgICBnYW1lVHlwZTogTU9DS19EQVRBLmdhbWVUeXBlLFxyXG4gICAgICAgIGF2YXRhcklkOiBNT0NLX0RBVEEuYXZhdGFySWQsXHJcbiAgICAgICAgYXV0b1RyYWNrOiBmYWxzZVxyXG4gICAgICB9KSwgeyB3cmFwcGVyIH0pO1xyXG5cclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zdGFydFNlc3Npb24oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVbm1vdW50IGNvbXBvbmVudFxyXG4gICAgICB1bm1vdW50KCk7XHJcblxyXG4gICAgICAvLyBObyBtZW1vcnkgbGVha3Mgb3IgaGFuZ2luZyBwcm9taXNlcyBzaG91bGQgcmVtYWluXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1RyYWNraW5nKS50b0JlKHRydWUpOyAvLyBTdGF0ZSBwcmVzZXJ2ZWQgdW50aWwgY2xlYW51cFxyXG4gICAgfSwgVEVTVF9USU1FT1VUUy5GQVNUKTtcclxuICB9KTtcclxufSk7ICJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tBbmFseXRpY3NTZXJ2aWNlIiwiYW5hbHl0aWNzU2VydmljZSIsIlRFU1RfVElNRU9VVFMiLCJGQVNUIiwiTUVESVVNIiwiU0xPVyIsIk1PQ0tfREFUQSIsImF2YXRhcklkIiwiZ2FtZVR5cGUiLCJzZXNzaW9uSWQiLCJyZWNvbW1lbmRhdGlvbnMiLCJnYW1lSWQiLCJyZWFzb24iLCJwcmlvcml0eSIsImVzdGltYXRlZERpZmZpY3VsdHkiLCJsZWFybmluZ09iamVjdGl2ZXMiLCJwcmVyZXF1aXNpdGVzTWV0IiwibWV0cmljcyIsInRvdGFsR2FtZXNQbGF5ZWQiLCJhdmVyYWdlU2Vzc2lvbkR1cmF0aW9uIiwib3ZlcmFsbENvbXBsZXRpb25SYXRlIiwic2tpbGxMZXZlbERpc3RyaWJ1dGlvbiIsImJlZ2lubmVyIiwic3ViamVjdFByZWZlcmVuY2VzIiwiTWF0aGVtYXRpY3MiLCJsZWFybmluZ1ZlbG9jaXR5IiwiZW5nYWdlbWVudFNjb3JlIiwiZGVzY3JpYmUiLCJ3cmFwcGVyIiwiY2hpbGRyZW4iLCJTZXR0aW5nc1Byb3ZpZGVyIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJzdGFydEdhbWVTZXNzaW9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ0cmFja0V2ZW50IiwidW5kZWZpbmVkIiwiY29tcGxldGVHYW1lU2Vzc2lvbiIsImdldExlYXJuaW5nUGF0aFJlY29tbWVuZGF0aW9ucyIsImdldFBlcmZvcm1hbmNlTWV0cmljcyIsImFmdGVyRWFjaCIsInJlc2V0QWxsTW9ja3MiLCJ1c2VSZWFsVGltZXJzIiwiaXQiLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlR2FtZUFuYWx5dGljcyIsImF1dG9UcmFjayIsImFjdCIsInN0YXJ0UHJvbWlzZSIsImN1cnJlbnQiLCJzdGFydFNlc3Npb24iLCJQcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIk9iamVjdCIsInRvQmUiLCJpc1RyYWNraW5nIiwidGVzdEVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJjb25zb2xlU3B5Iiwic3B5T24iLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZXJyb3IiLCJ0b0JlTnVsbCIsIm1vY2tSZXN0b3JlIiwicHJvbWlzZXMiLCJhbGwiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJ3YWl0Rm9yIiwidGltZW91dCIsInRyYWNrUXVlc3Rpb25BdHRlbXB0IiwicXVlc3Rpb25JbmRleCIsInJlc3BvbnNlVGltZSIsImRpZmZpY3VsdHkiLCJvYmplY3RDb250YWluaW5nIiwiY29ycmVjdCIsInRyYWNraW5nRXJyb3IiLCJyZXNvbHZlcyIsIm5vdCIsInRvVGhyb3ciLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiY29tcGxldGVTZXNzaW9uIiwiTnVtYmVyIiwidG9FcXVhbCIsInBlcmZvcm1hbmNlTWV0cmljcyIsImNvbXBsZXRpb25FcnJvciIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93Iiwic2Vzc2lvblN0YXJ0VGltZSIsInRvQmVMZXNzVGhhbiIsInRyYWNrU3RhcnRUaW1lIiwidHJhY2tUaW1lIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiaSIsInVubW91bnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Q0FTQztBQU9ELDZCQUE2QjtBQUM3QkEsS0FBS0MsSUFBSSxDQUFDOzs7Ozt1QkFOK0I7a0NBQ1I7a0NBQ0E7aUNBQ0E7QUFLakMsd0RBQXdEO0FBQ3hELE1BQU1DLHVCQUF1QkMsa0NBQWdCO0FBRTdDLGlCQUFpQjtBQUNqQixNQUFNQyxnQkFBZ0I7SUFDcEJDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxNQUFNO0FBQ1I7QUFFQSxNQUFNQyxZQUFZO0lBQ2hCQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxpQkFBaUI7UUFDZjtZQUNFQyxRQUFRO1lBQ1JDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxxQkFBcUI7WUFDckJDLG9CQUFvQixFQUFFO1lBQ3RCQyxrQkFBa0I7UUFDcEI7S0FDRDtJQUNEQyxTQUFTO1FBQ1BDLGtCQUFrQjtRQUNsQkMsd0JBQXdCO1FBQ3hCQyx1QkFBdUI7UUFDdkJDLHdCQUF3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