{"version":3,"sources":["C:\\repos\\family-oriented\\src\\utils\\analyticsService.ts"],"sourcesContent":["/**\r\n * Comprehensive Analytics Service for Game Tracking and Learning Progression\r\n * Supports both individual user analytics and aggregate platform metrics\r\n * Integrated with Supabase for persistent data storage\r\n */\r\n\r\nimport { GameType } from './gameUtils';\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport type { Json } from '@/lib/supabase/database.types';\r\nimport { logger } from './logger';\r\n\r\n// Core interfaces for analytics data\r\nexport interface GameSessionData {\r\n  id: string;\r\n  avatarId: string;\r\n  orgId?: string;\r\n  gameId: GameType;\r\n  sessionStart: Date;\r\n  sessionEnd?: Date;\r\n  totalDuration: number; // seconds\r\n  questionsAttempted: number;\r\n  questionsCorrect: number;\r\n  completionStatus: 'completed' | 'abandoned' | 'in_progress';\r\n  difficultyLevel: string;\r\n  settingsUsed: Record<string, unknown>;\r\n  scoreData?: {\r\n    finalScore: number;\r\n    accuracy: number;\r\n    questionsCorrect: number;\r\n    questionsAttempted: number;\r\n    completionRate: number;\r\n  };\r\n}\r\n\r\nexport interface GameEventData {\r\n  sessionId: string;\r\n  avatarId: string;\r\n  eventType: \r\n    | 'game_start' \r\n    | 'game_complete' \r\n    | 'question_start' \r\n    | 'question_answer' \r\n    | 'hint_used' \r\n    | 'game_pause' \r\n    | 'game_resume' \r\n    | 'difficulty_change' \r\n    | 'game_abandon'\r\n    | 'wizard_start'\r\n    | 'wizard_complete'\r\n    | 'wizard_game_complete';\r\n  eventData: Record<string, unknown>;\r\n  timestamp: Date;\r\n  sequenceNumber: number;\r\n}\r\n\r\nexport interface LearningProgressData {\r\n  avatarId: string;\r\n  gameId: GameType;\r\n  skillLevel: 'beginner' | 'intermediate' | 'advanced';\r\n  masteryScore: number; // 0-100\r\n  learningObjectivesMet: string[];\r\n  prerequisiteCompletion: Record<string, boolean>;\r\n  lastPlayed: Date;\r\n  totalSessions: number;\r\n  averagePerformance: number;\r\n  improvementTrend: 'improving' | 'stable' | 'declining';\r\n}\r\n\r\nexport interface LearningPathRecommendation {\r\n  gameId: string;\r\n  reason: string;\r\n  priority: number; // 1-10, higher is more recommended\r\n  estimatedDifficulty: string;\r\n  learningObjectives: string[];\r\n  prerequisitesMet: boolean;\r\n}\r\n\r\nexport interface PerformanceMetrics {\r\n  totalGamesPlayed: number;\r\n  averageSessionDuration: number;\r\n  overallCompletionRate: number;\r\n  skillLevelDistribution: Record<string, number>;\r\n  subjectPreferences: Record<string, number>;\r\n  learningVelocity: number; // objectives mastered per week\r\n  engagementScore: number; // 0-100\r\n}\r\n\r\n/**\r\n * Supabase-Integrated Analytics Service Class\r\n * Handles all game tracking, learning progression, and performance analytics\r\n * with persistent storage via Supabase\r\n */\r\nexport class SupabaseAnalyticsService {\r\n  private supabase = createClient();\r\n  \r\n  // Local cache for performance (still maintain for complex calculations)\r\n  private sessionCache: Map<string, GameSessionData> = new Map();\r\n  private eventSequenceCounters: Map<string, number> = new Map();\r\n\r\n  /**\r\n   * Start tracking a new game session (Supabase-integrated)\r\n   */\r\n  async startGameSession(\r\n    avatarId: string,\r\n    gameType: string, // Using gameType to match Supabase schema\r\n    settings: Record<string, unknown>,\r\n    orgId?: string\r\n  ): Promise<string> {\r\n    const { data, error } = await this.supabase\r\n      .from('game_sessions')\r\n      .insert({\r\n        avatar_id: avatarId,\r\n        org_id: orgId,\r\n        game_type: gameType,\r\n        settings_used: settings as Json,\r\n        session_start: new Date().toISOString()\r\n      })\r\n      .select('id')\r\n      .single();\r\n\r\n    if (error) throw error;\r\n\r\n    // Cache session locally for immediate access\r\n    const session: GameSessionData = {\r\n      id: data.id,\r\n      avatarId,\r\n      orgId,\r\n      gameId: gameType as GameType,\r\n      sessionStart: new Date(),\r\n      totalDuration: 0,\r\n      questionsAttempted: 0,\r\n      questionsCorrect: 0,\r\n      completionStatus: 'in_progress',\r\n      difficultyLevel: 'beginner',\r\n      settingsUsed: settings\r\n    };\r\n\r\n    this.sessionCache.set(data.id, session);\r\n    this.eventSequenceCounters.set(data.id, 0);\r\n    \r\n    // Track session start event\r\n    await this.trackEvent(data.id, avatarId, 'game_start', { gameType, settings });\r\n    \r\n    return data.id;\r\n  }\r\n\r\n  /**\r\n   * Track individual game events during a session (Supabase-integrated)\r\n   */\r\n  async trackEvent(\r\n    sessionId: string,\r\n    avatarId: string,\r\n    eventType: GameEventData['eventType'],\r\n    eventData: Record<string, unknown>\r\n  ): Promise<void> {\r\n    const sequenceNumber = (this.eventSequenceCounters.get(sessionId) || 0) + 1;\r\n    this.eventSequenceCounters.set(sessionId, sequenceNumber);\r\n\r\n    const { error } = await this.supabase\r\n      .from('game_events')\r\n      .insert({\r\n        session_id: sessionId,\r\n        avatar_id: avatarId,\r\n        event_type: eventType,\r\n        event_data: eventData as Json,\r\n        timestamp: new Date().toISOString(),\r\n        sequence_number: sequenceNumber\r\n      });\r\n\r\n    if (error) throw error;\r\n\r\n    // Update local cache if session exists\r\n    const session = this.sessionCache.get(sessionId);\r\n    if (session) {\r\n      this.updateSessionFromEvent(session, {\r\n        sessionId,\r\n        avatarId,\r\n        eventType,\r\n        eventData,\r\n        timestamp: new Date(),\r\n        sequenceNumber\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Complete a game session and calculate final metrics (Supabase-integrated)\r\n   */\r\n  async completeGameSession(\r\n    sessionId: string,\r\n    finalScore: number,\r\n    questionsAttempted: number,\r\n    questionsCorrect: number\r\n  ): Promise<void> {\r\n    const scoreData = {\r\n      finalScore,\r\n      accuracy: questionsAttempted > 0 ? questionsCorrect / questionsAttempted : 0,\r\n      questionsCorrect,\r\n      questionsAttempted,\r\n      completionRate: 1.0\r\n    };\r\n\r\n    // Calculate duration from cached session or fetch from DB\r\n    let totalDuration = 0;\r\n    const cachedSession = this.sessionCache.get(sessionId);\r\n    if (cachedSession) {\r\n      totalDuration = Math.floor((new Date().getTime() - cachedSession.sessionStart.getTime()) / 1000);\r\n    }\r\n\r\n    const { error } = await this.supabase\r\n      .from('game_sessions')\r\n      .update({\r\n        session_end: new Date().toISOString(),\r\n        total_duration: totalDuration,\r\n        questions_attempted: questionsAttempted,\r\n        questions_correct: questionsCorrect,\r\n        completion_status: 'completed',\r\n        score_data: scoreData\r\n      })\r\n      .eq('id', sessionId);\r\n\r\n    if (error) throw error;\r\n\r\n    // Track completion event\r\n    await this.trackEvent(sessionId, cachedSession?.avatarId || '', 'game_complete', {\r\n      finalScore,\r\n      questionsAttempted,\r\n      questionsCorrect,\r\n      duration: totalDuration\r\n    });\r\n\r\n    // Update learning progress\r\n    if (cachedSession) {\r\n      await this.updateLearningProgress(cachedSession, finalScore);\r\n    }\r\n\r\n    // Clean up cache\r\n    this.sessionCache.delete(sessionId);\r\n    this.eventSequenceCounters.delete(sessionId);\r\n  }\r\n\r\n  /**\r\n   * Get learning progress for an avatar (Smart routing: demo-first approach)\r\n   */\r\n  async getAvatarProgress(avatarId: string): Promise<LearningProgressData[]> {\r\n    logger.debug(`[Analytics] Getting avatar progress for: ${avatarId}`);\r\n    \r\n    // Smart routing - check if we should use database or demo data\r\n    if (!this.shouldUseDatabase(avatarId)) {\r\n      logger.info(`[Analytics] Using demo data for avatar: ${avatarId}`);\r\n      return this.generateDemoProgress(avatarId);\r\n    }\r\n    \r\n    // Real user - use database\r\n    logger.debug(`[Analytics] Using database for real user avatar: ${avatarId}`);\r\n    \r\n    try {\r\n      const { data, error } = await this.supabase\r\n        .from('learning_progress')\r\n        .select('*')\r\n        .eq('avatar_id', avatarId)\r\n        .order('last_played', { ascending: false });\r\n\r\n      if (error) {\r\n        logger.error(`[Analytics] Database error for avatar ${avatarId}:`, error);\r\n        throw error;\r\n      }\r\n\r\n      // Transform Supabase data to our interface\r\n      const progressData = (data || []).map(row => ({\r\n        avatarId: row.avatar_id,\r\n        gameId: row.game_type as GameType,\r\n        skillLevel: row.skill_level as 'beginner' | 'intermediate' | 'advanced',\r\n        masteryScore: row.mastery_score || 0,\r\n        learningObjectivesMet: row.learning_objectives_met || [],\r\n        prerequisiteCompletion: (row.prerequisite_completion as Record<string, boolean>) || {},\r\n        lastPlayed: new Date(row.last_played),\r\n        totalSessions: row.total_sessions || 0,\r\n        averagePerformance: row.average_performance || 0,\r\n        improvementTrend: row.improvement_trend as 'improving' | 'stable' | 'declining'\r\n      }));\r\n\r\n      logger.debug(`[Analytics] Found ${progressData.length} progress records for avatar ${avatarId}`);\r\n      return progressData;\r\n      \r\n    } catch (error) {\r\n      logger.error(`[Analytics] Error in getAvatarProgress for ${avatarId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get game sessions for an avatar (Smart routing: demo-first approach)\r\n   */\r\n  async getAvatarSessions(avatarId: string, limit?: number): Promise<GameSessionData[]> {\r\n    logger.debug(`[Analytics] Getting avatar sessions for: ${avatarId}`);\r\n    \r\n    // Smart routing - check if we should use database or demo data\r\n    if (!this.shouldUseDatabase(avatarId)) {\r\n      logger.info(`[Analytics] Using demo session data for avatar: ${avatarId}`);\r\n      return this.generateDemoSessions(avatarId, limit);\r\n    }\r\n    \r\n    // Real user - use database\r\n    logger.debug(`[Analytics] Using database for real user avatar: ${avatarId}`);\r\n    \r\n    try {\r\n      let query = this.supabase\r\n        .from('game_sessions')\r\n        .select('*')\r\n        .eq('avatar_id', avatarId)\r\n        .order('session_start', { ascending: false });\r\n\r\n      if (limit) {\r\n        query = query.limit(limit);\r\n      }\r\n\r\n      const { data, error } = await query;\r\n      if (error) {\r\n        logger.error(`[Analytics] Database error getting sessions for avatar ${avatarId}:`, error);\r\n        throw error;\r\n      }\r\n\r\n      logger.debug(`[Analytics] Raw session data from database:`, data);\r\n      logger.debug(`[Analytics] Number of sessions found: ${data?.length || 0}`);\r\n\r\n      // Transform Supabase data to our interface\r\n      const transformedData = (data || []).map(row => ({\r\n        id: row.id,\r\n        avatarId: row.avatar_id,\r\n        orgId: row.org_id || undefined,\r\n        gameId: row.game_type as GameType,\r\n        sessionStart: new Date(row.session_start),\r\n        sessionEnd: row.session_end ? new Date(row.session_end) : undefined,\r\n        totalDuration: row.total_duration || 0,\r\n        questionsAttempted: row.questions_attempted || 0,\r\n        questionsCorrect: row.questions_correct || 0,\r\n        completionStatus: row.completion_status as 'completed' | 'abandoned' | 'in_progress',\r\n        difficultyLevel: row.difficulty_level,\r\n        settingsUsed: (row.settings_used as Record<string, unknown>) || {},\r\n        scoreData: row.score_data as {\r\n          finalScore: number;\r\n          accuracy: number;\r\n          questionsCorrect: number;\r\n          questionsAttempted: number;\r\n          completionRate: number;\r\n        }\r\n      }));\r\n\r\n      logger.debug(`[Analytics] Transformed ${transformedData.length} session records for avatar ${avatarId}`);\r\n      return transformedData;\r\n      \r\n    } catch (error) {\r\n      logger.error(`[Analytics] Error in getAvatarSessions for ${avatarId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get learning path recommendations for an avatar\r\n   */\r\n  async getLearningPathRecommendations(avatarId: string, maxRecommendations: number = 5): Promise<LearningPathRecommendation[]> {\r\n    const progress = await this.getAvatarProgress(avatarId);\r\n    const recommendations: LearningPathRecommendation[] = [];\r\n\r\n    // Import games data for analysis\r\n    const availableGames = this.getAvailableGames();\r\n    logger.debug('Available games:', availableGames.length);\r\n\r\n    // If no progress yet, recommend beginner games\r\n    if (progress.length === 0) {\r\n      logger.debug('No progress found, recommending beginner games');\r\n      return availableGames\r\n        .filter(game => game.skillLevel === 'beginner')\r\n        .slice(0, maxRecommendations)\r\n        .map(game => ({\r\n          gameId: game.id,\r\n          reason: 'Great game to start with!',\r\n          priority: 8,\r\n          estimatedDifficulty: 'beginner',\r\n          learningObjectives: game.learningObjectives || [],\r\n          prerequisitesMet: true\r\n        }));\r\n    }\r\n\r\n    logger.debug('Processing recommendations for progress:', progress.length, 'games');\r\n\r\n    // First, recommend games that need improvement\r\n    const needsImprovement = progress\r\n      .filter(p => p.masteryScore < 70)\r\n      .sort((a, b) => a.masteryScore - b.masteryScore);\r\n\r\n    for (const gameProgress of needsImprovement) {\r\n      const game = availableGames.find(g => g.id === gameProgress.gameId);\r\n      if (game) {\r\n        recommendations.push({\r\n          gameId: game.id,\r\n          reason: `Keep practicing to improve your ${game.id} skills!`,\r\n          priority: 9,\r\n          estimatedDifficulty: gameProgress.skillLevel,\r\n          learningObjectives: game.learningObjectives || [],\r\n          prerequisitesMet: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // Then, recommend new games in the same subject as games with good progress\r\n    const goodProgress = progress.filter(p => p.masteryScore >= 70);\r\n    const subjectsToExplore = new Set(goodProgress.map(p => this.getGameSubject(p.gameId)));\r\n\r\n    for (const subject of subjectsToExplore) {\r\n      const newGamesInSubject = availableGames\r\n        .filter(game => \r\n          this.getGameSubject(game.id) === subject && \r\n          !progress.some(p => p.gameId === game.id)\r\n        );\r\n\r\n      for (const game of newGamesInSubject) {\r\n        recommendations.push({\r\n          gameId: game.id,\r\n          reason: `Try this ${subject} game to expand your skills!`,\r\n          priority: 7,\r\n          estimatedDifficulty: 'beginner',\r\n          learningObjectives: game.learningObjectives || [],\r\n          prerequisitesMet: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // Finally, add any remaining games not yet played\r\n    const playedGames = new Set(progress.map(p => p.gameId));\r\n    const unplayedGames = availableGames.filter(game => !playedGames.has(game.id as GameType));\r\n\r\n    for (const game of unplayedGames) {\r\n      if (recommendations.length < maxRecommendations) {\r\n        recommendations.push({\r\n          gameId: game.id,\r\n          reason: 'New game to explore!',\r\n          priority: 6,\r\n          estimatedDifficulty: 'beginner',\r\n          learningObjectives: game.learningObjectives || [],\r\n          prerequisitesMet: true\r\n        });\r\n      }\r\n    }\r\n\r\n    logger.debug('Generated recommendations:', recommendations.length);\r\n\r\n    // Sort by priority and return top recommendations\r\n    return recommendations\r\n      .sort((a, b) => b.priority - a.priority)\r\n      .slice(0, maxRecommendations);\r\n  }\r\n\r\n  private getGameSubject(gameId: string): string {\r\n    const subjectMap: Record<string, string> = {\r\n      'numbers': 'Mathematics',\r\n      'math': 'Mathematics',\r\n      'letters': 'Language Arts',\r\n      'colors': 'Visual Arts',\r\n      'shapes': 'Visual Arts',\r\n      'geography': 'Social Studies'\r\n    };\r\n    return subjectMap[gameId] || 'Other';\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive performance metrics for an avatar (Smart routing: demo-first approach)\r\n   */\r\n  async getPerformanceMetrics(avatarId: string): Promise<PerformanceMetrics> {\r\n    logger.debug(`[Analytics] Getting performance metrics for: ${avatarId}`);\r\n    \r\n    // Smart routing - check if we should use database or demo data\r\n    if (!this.shouldUseDatabase(avatarId)) {\r\n      logger.info(`[Analytics] Using demo metrics for avatar: ${avatarId}`);\r\n      return this.generateDemoMetrics(avatarId);\r\n    }\r\n    \r\n    // Real user - use database\r\n    logger.debug(`[Analytics] Using database for real user avatar: ${avatarId}`);\r\n    \r\n    try {\r\n      const [progress, sessions] = await Promise.all([\r\n        this.getAvatarProgress(avatarId),\r\n        this.getAvatarSessions(avatarId)\r\n      ]);\r\n\r\n      logger.debug('=== PERFORMANCE METRICS DEBUG ===');\r\n      logger.debug('Avatar ID:', avatarId);\r\n      logger.debug('Total sessions found:', sessions.length);\r\n      logger.debug('Progress records found:', progress.length);\r\n\r\n      // Basic metrics\r\n      const totalGamesPlayed = sessions.length;\r\n      logger.debug('Total games played:', totalGamesPlayed);\r\n      \r\n      const completedSessions = sessions.filter(s => s.completionStatus === 'completed');\r\n      logger.debug('Completed sessions:', completedSessions.length);\r\n      \r\n      const averageSessionDuration = completedSessions.length > 0\r\n        ? completedSessions.reduce((sum, s) => sum + (s.totalDuration || 0), 0) / completedSessions.length\r\n        : 0;\r\n      logger.debug('Average session duration (seconds):', averageSessionDuration);\r\n      \r\n      const overallCompletionRate = totalGamesPlayed > 0\r\n        ? completedSessions.length / totalGamesPlayed\r\n        : 0;\r\n      logger.debug('Overall completion rate:', overallCompletionRate);\r\n\r\n      // Calculate skill level distribution\r\n      const skillLevelDistribution = progress.reduce((dist, p) => {\r\n        dist[p.skillLevel] = (dist[p.skillLevel] || 0) + 1;\r\n        return dist;\r\n      }, {} as Record<string, number>);\r\n      logger.debug('Skill level distribution:', skillLevelDistribution);\r\n\r\n      // Calculate subject preferences based on play frequency and performance\r\n      const subjectPreferences = this.calculateSubjectPreferences(sessions);\r\n      logger.debug('Subject preferences:', subjectPreferences);\r\n\r\n      // Calculate learning velocity (objectives mastered per week)\r\n      const learningVelocity = this.calculateLearningVelocity(progress);\r\n      logger.debug('Learning velocity:', learningVelocity);\r\n\r\n      // Calculate engagement score based on various factors\r\n      const engagementScore = this.calculateEngagementScore(sessions);\r\n      logger.debug('Engagement score calculation details:');\r\n      logger.debug('- Sessions for engagement:', sessions.length);\r\n      logger.debug('- Completed for engagement:', completedSessions.length);\r\n      logger.debug('- Final engagement score:', engagementScore);\r\n\r\n      const metrics = {\r\n        totalGamesPlayed,\r\n        averageSessionDuration,\r\n        overallCompletionRate,\r\n        skillLevelDistribution,\r\n        subjectPreferences,\r\n        learningVelocity,\r\n        engagementScore\r\n      };\r\n\r\n      logger.debug('=== FINAL CALCULATED METRICS ===');\r\n      logger.debug(metrics);\r\n      return metrics;\r\n      \r\n    } catch (error) {\r\n      logger.error(`[Analytics] Error getting data for performance metrics for ${avatarId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get aggregate analytics for platform-wide metrics (Supabase-integrated)\r\n   */\r\n  async getAggregateAnalytics(orgId?: string): Promise<{\r\n    totalSessions: number;\r\n    uniquePlayers: number;\r\n    averageDuration: number;\r\n    completionRate: number;\r\n    popularGames: Array<{ gameId: GameType; sessions: number; avgScore: number }>;\r\n    learningEffectiveness: Record<string, number>;\r\n  }> {\r\n    let query = this.supabase\r\n      .from('game_sessions')\r\n      .select('*');\r\n\r\n    if (orgId) {\r\n      query = query.eq('org_id', orgId);\r\n    }\r\n\r\n    const { data: sessions, error } = await query;\r\n    if (error) throw error;\r\n\r\n    const sessionData = sessions || [];\r\n    const totalSessions = sessionData.length;\r\n    const uniquePlayers = new Set(sessionData.map(s => s.avatar_id)).size;\r\n    const averageDuration = sessionData.reduce((sum, s) => sum + (s.total_duration || 0), 0) / totalSessions || 0;\r\n    const completedSessions = sessionData.filter(s => s.completion_status === 'completed');\r\n    const completionRate = completedSessions.length / totalSessions || 0;\r\n\r\n    // Calculate popular games\r\n    const gameStats = sessionData.reduce((stats, session) => {\r\n      const gameType = session.game_type;\r\n      if (!stats[gameType]) {\r\n        stats[gameType] = { sessions: 0, totalScore: 0, completedSessions: 0 };\r\n      }\r\n      stats[gameType].sessions++;\r\n      if (session.completion_status === 'completed' && session.score_data) {\r\n        stats[gameType].completedSessions++;\r\n        const scoreData = session.score_data as Record<string, unknown>;\r\n        const finalScore = typeof scoreData?.finalScore === 'number' ? scoreData.finalScore : 0;\r\n        stats[gameType].totalScore += finalScore;\r\n      }\r\n      return stats;\r\n    }, {} as Record<string, { sessions: number; totalScore: number; completedSessions: number }>);\r\n\r\n    const popularGames = Object.entries(gameStats)\r\n      .map(([gameId, stats]) => {\r\n        const statData = stats as { sessions: number; totalScore: number; completedSessions: number };\r\n        return {\r\n          gameId: gameId as GameType,\r\n          sessions: statData.sessions,\r\n          avgScore: statData.completedSessions > 0 ? statData.totalScore / statData.completedSessions : 0\r\n        };\r\n      })\r\n      .sort((a, b) => b.sessions - a.sessions);\r\n\r\n    // Transform raw session data to GameSessionData format\r\n    const transformedSessions: GameSessionData[] = sessionData.map(row => ({\r\n      id: row.id,\r\n      avatarId: row.avatar_id,\r\n      orgId: row.org_id || undefined,\r\n      gameId: row.game_type as GameType,\r\n      sessionStart: new Date(row.session_start),\r\n      sessionEnd: row.session_end ? new Date(row.session_end) : undefined,\r\n      totalDuration: row.total_duration || 0,\r\n      questionsAttempted: row.questions_attempted || 0,\r\n      questionsCorrect: row.questions_correct || 0,\r\n      completionStatus: row.completion_status as 'completed' | 'abandoned' | 'in_progress',\r\n      difficultyLevel: row.difficulty_level,\r\n      settingsUsed: (row.settings_used as Record<string, unknown>) || {},\r\n      scoreData: row.score_data as {\r\n        finalScore: number;\r\n        accuracy: number;\r\n        questionsCorrect: number;\r\n        questionsAttempted: number;\r\n        completionRate: number;\r\n      }\r\n    }));\r\n\r\n    // Calculate learning effectiveness by subject\r\n    const learningEffectiveness = this.calculateLearningEffectivenessFromSessions(transformedSessions);\r\n\r\n    return {\r\n      totalSessions,\r\n      uniquePlayers,\r\n      averageDuration,\r\n      completionRate,\r\n      popularGames,\r\n      learningEffectiveness\r\n    };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private updateSessionFromEvent(session: GameSessionData, event: GameEventData): void {\r\n    switch (event.eventType) {\r\n      case 'question_answer':\r\n        session.questionsAttempted++;\r\n        if (event.eventData.correct) {\r\n          session.questionsCorrect++;\r\n        }\r\n        break;\r\n      case 'difficulty_change':\r\n        session.difficultyLevel = event.eventData.newDifficulty as string;\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async updateLearningProgress(session: GameSessionData, finalScore: number): Promise<void> {\r\n    // Check if progress record exists\r\n    const { data: existingProgress } = await this.supabase\r\n      .from('learning_progress')\r\n      .select('*')\r\n      .eq('avatar_id', session.avatarId)\r\n      .eq('game_type', session.gameId)\r\n      .single();\r\n\r\n    const now = new Date().toISOString();\r\n    \r\n    if (!existingProgress) {\r\n      // Create new progress record\r\n      const { error } = await this.supabase\r\n        .from('learning_progress')\r\n        .insert({\r\n          avatar_id: session.avatarId,\r\n          org_id: session.orgId,\r\n          game_type: session.gameId,\r\n          skill_level: 'beginner',\r\n          mastery_score: finalScore,\r\n          learning_objectives_met: [],\r\n          prerequisite_completion: {},\r\n          last_played: now,\r\n          total_sessions: 1,\r\n          average_performance: finalScore,\r\n          improvement_trend: 'stable',\r\n          needs_realtime_update: true\r\n        });\r\n\r\n      if (error) throw error;\r\n    } else {\r\n      // Update existing progress\r\n      const totalSessions = (existingProgress.total_sessions || 0) + 1;\r\n      const previousAverage = existingProgress.average_performance || 0;\r\n      const newAverage = (previousAverage * (totalSessions - 1) + finalScore) / totalSessions;\r\n      \r\n      // Determine improvement trend\r\n      let improvementTrend = 'stable';\r\n      if (totalSessions > 1) {\r\n        if (newAverage > previousAverage * 1.1) {\r\n          improvementTrend = 'improving';\r\n        } else if (newAverage < previousAverage * 0.9) {\r\n          improvementTrend = 'declining';\r\n        }\r\n      }\r\n\r\n      // Update mastery score (weighted average favoring recent performance)\r\n      const masteryScore = Math.min(100, ((existingProgress.mastery_score || 0) * 0.7) + (finalScore * 0.3));\r\n\r\n      // Check for skill level advancement\r\n      let skillLevel = existingProgress.skill_level;\r\n      if (masteryScore >= 80 && skillLevel === 'beginner') {\r\n        skillLevel = 'intermediate';\r\n      } else if (masteryScore >= 90 && skillLevel === 'intermediate') {\r\n        skillLevel = 'advanced';\r\n      }\r\n\r\n      const { error } = await this.supabase\r\n        .from('learning_progress')\r\n        .update({\r\n          skill_level: skillLevel,\r\n          mastery_score: masteryScore,\r\n          last_played: now,\r\n          total_sessions: totalSessions,\r\n          average_performance: newAverage,\r\n          improvement_trend: improvementTrend,\r\n          needs_realtime_update: true,\r\n          updated_at: now\r\n        })\r\n        .eq('id', existingProgress.id);\r\n\r\n      if (error) throw error;\r\n    }\r\n  }\r\n\r\n  private calculateGameRecommendation(\r\n    game: { id: string; prerequisites?: string[]; learningObjectives?: string[] }, \r\n    gameProgress?: LearningProgressData, \r\n    allProgress?: LearningProgressData[]\r\n  ): LearningPathRecommendation | null {\r\n    let priority = 5; // base priority\r\n    let reason = 'Recommended for continued learning';\r\n\r\n    // Check prerequisites\r\n    const prerequisitesMet = this.checkPrerequisites(game, allProgress || []);\r\n    if (!prerequisitesMet) {\r\n      return null; // Don't recommend if prerequisites not met\r\n    }\r\n\r\n    // Boost priority for games not yet played\r\n    if (!gameProgress) {\r\n      priority += 2;\r\n      reason = 'New game to explore';\r\n    }\r\n\r\n    // Boost priority for games where user is improving\r\n    if (gameProgress?.improvementTrend === 'improving') {\r\n      priority += 1;\r\n      reason = 'You\\'re making great progress here!';\r\n    }\r\n\r\n    // Lower priority for mastered games\r\n    if (gameProgress?.masteryScore && gameProgress.masteryScore >= 90) {\r\n      priority -= 2;\r\n      reason = 'Review and reinforce mastered skills';\r\n    }\r\n\r\n    return {\r\n      gameId: game.id,\r\n      reason,\r\n      priority: Math.max(1, Math.min(10, priority)),\r\n      estimatedDifficulty: gameProgress?.skillLevel || 'beginner',\r\n      learningObjectives: game.learningObjectives || [],\r\n      prerequisitesMet\r\n    };\r\n  }\r\n\r\n  private checkPrerequisites(game: { prerequisites?: string[] }, progress: LearningProgressData[]): boolean {\r\n    if (!game.prerequisites || game.prerequisites.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    return game.prerequisites.every((prereqId: string) => {\r\n      const prereqProgress = progress.find(p => p.gameId === prereqId);\r\n      return prereqProgress && prereqProgress.masteryScore >= 70; // 70% mastery required\r\n    });\r\n  }\r\n\r\n  private calculateSubjectPreferences(sessions: GameSessionData[]): Record<string, number> {\r\n    const preferences: Record<string, number> = {};\r\n    const gameTypes = new Set(sessions.map(s => s.gameId));\r\n    \r\n    gameTypes.forEach(gameType => {\r\n      const gameSessions = sessions.filter(s => s.gameId === gameType);\r\n      const completedSessions = gameSessions.filter(s => s.completionStatus === 'completed');\r\n      \r\n      if (completedSessions.length > 0) {\r\n        const averageScore = completedSessions.reduce((sum, s) => {\r\n          // Use the scoreData field directly\r\n          const score = s.scoreData?.finalScore || 0;\r\n          return sum + score;\r\n        }, 0) / completedSessions.length;\r\n        \r\n        preferences[gameType] = averageScore;\r\n      }\r\n    });\r\n\r\n    return preferences;\r\n  }\r\n\r\n  private calculateLearningVelocity(progress: LearningProgressData[]): number {\r\n    if (progress.length === 0) return 0;\r\n\r\n    // Count objectives mastered in the last week\r\n    const oneWeekAgo = new Date();\r\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\r\n\r\n    const recentProgress = progress.filter(p => \r\n      p.lastPlayed >= oneWeekAgo && p.masteryScore >= 80\r\n    );\r\n\r\n    return recentProgress.length;\r\n  }\r\n\r\n  private calculateEngagementScore(sessions: GameSessionData[]): number {\r\n    if (sessions.length === 0) return 0;\r\n\r\n    const factors = {\r\n      sessionFrequency: 0,\r\n      completionRate: 0,\r\n      averageDuration: 0,\r\n      consistency: 0\r\n    };\r\n\r\n    // Session frequency (0-25 points)\r\n    const sessionCount = sessions.length;\r\n    factors.sessionFrequency = Math.min(25, sessionCount * 2);\r\n\r\n    // Completion rate (0-25 points)\r\n    const completedSessions = sessions.filter(s => s.completionStatus === 'completed');\r\n    const completionRate = completedSessions.length / sessionCount;\r\n    factors.completionRate = completionRate * 25;\r\n\r\n    // Average duration (0-25 points)\r\n    const totalDuration = completedSessions.reduce((sum, s) => sum + (s.totalDuration || 0), 0);\r\n    const avgDuration = completedSessions.length > 0 ? totalDuration / completedSessions.length : 0;\r\n    factors.averageDuration = Math.min(25, avgDuration / 60); // Convert to minutes and cap at 25\r\n\r\n    // Consistency (0-25 points)\r\n    const recentSessions = sessions.slice(-5);\r\n    const recentCompletionRate = recentSessions.filter(s => s.completionStatus === 'completed').length / recentSessions.length;\r\n    factors.consistency = recentCompletionRate * 25;\r\n\r\n    // Calculate total engagement score (0-100)\r\n    const totalScore = Object.values(factors).reduce((sum, score) => sum + score, 0);\r\n    return Math.round(totalScore);\r\n  }\r\n\r\n  /**\r\n   * Calculate learning effectiveness metrics from session data\r\n   */\r\n  private calculateLearningEffectivenessFromSessions(sessions: GameSessionData[]): Record<string, number> {\r\n    const gameEffectiveness: Record<string, { totalScore: number; sessionCount: number }> = {};\r\n    \r\n    sessions.forEach(session => {\r\n      if (session.completionStatus === 'completed') {\r\n        const gameType = session.gameId;\r\n        const accuracy = session.scoreData?.accuracy || 0;\r\n        \r\n        if (!gameEffectiveness[gameType]) {\r\n          gameEffectiveness[gameType] = { totalScore: 0, sessionCount: 0 };\r\n        }\r\n        \r\n        gameEffectiveness[gameType].totalScore += accuracy;\r\n        gameEffectiveness[gameType].sessionCount += 1;\r\n      }\r\n    });\r\n\r\n    // Convert to average effectiveness scores\r\n    const effectiveness: Record<string, number> = {};\r\n    Object.keys(gameEffectiveness).forEach(gameType => {\r\n      const { totalScore, sessionCount } = gameEffectiveness[gameType];\r\n      effectiveness[gameType] = sessionCount > 0 ? totalScore / sessionCount : 0;\r\n    });\r\n\r\n    return effectiveness;\r\n  }\r\n\r\n  /**\r\n   * Get list of available games for recommendations\r\n   */\r\n  private getAvailableGames(): Array<{\r\n    id: string;\r\n    skillLevel: string;\r\n    learningObjectives: string[];\r\n    prerequisites?: string[];\r\n  }> {\r\n    // Define available games with their metadata\r\n    return [\r\n      {\r\n        id: 'numbers',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Number recognition', 'Basic counting'],\r\n        prerequisites: []\r\n      },\r\n      {\r\n        id: 'math',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Basic addition', 'Number patterns'],\r\n        prerequisites: ['numbers']\r\n      },\r\n      {\r\n        id: 'letters',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Letter recognition', 'Basic phonics'],\r\n        prerequisites: []\r\n      },\r\n      {\r\n        id: 'colors',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Color recognition', 'Color mixing'],\r\n        prerequisites: []\r\n      },\r\n      {\r\n        id: 'shapes',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Shape recognition', 'Basic geometry'],\r\n        prerequisites: []\r\n      },\r\n      {\r\n        id: 'geography',\r\n        skillLevel: 'beginner',\r\n        learningObjectives: ['Map reading', 'Basic geography'],\r\n        prerequisites: []\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Check if we're in demo mode - either by avatar ID or environment\r\n   */\r\n  private isDemoMode(): boolean {\r\n    // Check environment variable for global demo mode\r\n    if (process.env.NEXT_PUBLIC_DEMO_MODE === 'true') {\r\n      return true;\r\n    }\r\n    \r\n    // Check if we have a demo scenario set\r\n    if (typeof window !== 'undefined') {\r\n      const demoScenario = localStorage.getItem('demo_scenario');\r\n      if (demoScenario) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if an avatar ID belongs to a demo scenario\r\n   */\r\n  private isDemoAvatar(avatarId: string): boolean {\r\n    return avatarId.startsWith('demo-') || avatarId.startsWith('00000000-0000-0000-0000');\r\n  }\r\n\r\n  /**\r\n   * Smart analytics routing - demo first, then database\r\n   */\r\n  private shouldUseDatabase(avatarId: string): boolean {\r\n    // If it's clearly a demo avatar, skip database\r\n    if (this.isDemoAvatar(avatarId)) {\r\n      return false;\r\n    }\r\n    \r\n    // If we're in global demo mode, skip database\r\n    if (this.isDemoMode()) {\r\n      return false;\r\n    }\r\n    \r\n    // Otherwise, use database for real users\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Generate demo progress data for demo avatars when no real data exists\r\n   */\r\n  private generateDemoProgress(avatarId: string): LearningProgressData[] {\r\n    // Determine demo avatar characteristics based on ID\r\n    const demoProfile = this.getDemoAvatarProfile(avatarId);\r\n    const gameTypes: GameType[] = ['numbers', 'letters', 'colors', 'shapes', 'math'];\r\n    \r\n    return gameTypes.slice(0, 3).map((gameId, index) => {\r\n      const baseScore = demoProfile.baseScore + (Math.random() - 0.5) * 20;\r\n      const masteryScore = Math.max(0, Math.min(100, baseScore));\r\n      \r\n      return {\r\n        avatarId,\r\n        gameId,\r\n        skillLevel: demoProfile.skillLevel,\r\n        masteryScore: Math.round(masteryScore),\r\n        learningObjectivesMet: this.generateLearningObjectives(gameId, masteryScore),\r\n        prerequisiteCompletion: { 'basic_understanding': true },\r\n        lastPlayed: new Date(Date.now() - (index * 24 * 60 * 60 * 1000)), // Spread over last few days\r\n        totalSessions: Math.floor(Math.random() * 10) + 3,\r\n        averagePerformance: Math.round(masteryScore * 0.9),\r\n        improvementTrend: demoProfile.trend\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate demo performance metrics when no real data exists\r\n   */\r\n  private generateDemoMetrics(avatarId: string): PerformanceMetrics {\r\n    const demoProfile = this.getDemoAvatarProfile(avatarId);\r\n    \r\n    return {\r\n      totalGamesPlayed: Math.floor(Math.random() * 15) + 5,\r\n      averageSessionDuration: 120 + Math.random() * 180, // 2-5 minutes\r\n      overallCompletionRate: 0.7 + Math.random() * 0.25, // 70-95%\r\n      skillLevelDistribution: {\r\n        'beginner': demoProfile.skillLevel === 'beginner' ? 3 : 1,\r\n        'intermediate': demoProfile.skillLevel === 'intermediate' ? 3 : 1,\r\n        'advanced': demoProfile.skillLevel === 'advanced' ? 3 : 0\r\n      },\r\n      subjectPreferences: {\r\n        'Mathematics': 0.4 + Math.random() * 0.3,\r\n        'Language Arts': 0.3 + Math.random() * 0.3,\r\n        'Visual Arts': 0.2 + Math.random() * 0.2\r\n      },\r\n      learningVelocity: 2 + Math.random() * 3, // 2-5 objectives per week\r\n      engagementScore: demoProfile.baseScore + Math.random() * 15\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get demo avatar profile characteristics based on avatar ID\r\n   */\r\n  private getDemoAvatarProfile(avatarId: string): {\r\n    skillLevel: 'beginner' | 'intermediate' | 'advanced';\r\n    baseScore: number;\r\n    trend: 'improving' | 'stable' | 'declining';\r\n  } {\r\n    // Customize based on avatar ID patterns\r\n    if (avatarId.includes('personal-basic') || avatarId.includes('avatar-1')) {\r\n      return { skillLevel: 'beginner', baseScore: 60, trend: 'improving' };\r\n    } else if (avatarId.includes('personal-limit-avatar-3') || avatarId.includes('professional') || avatarId.includes('enterprise')) {\r\n      return { skillLevel: 'advanced', baseScore: 85, trend: 'stable' };\r\n    } else if (avatarId.includes('avatar-4') || avatarId.includes('00000000-0000-0000-0000-000000000013')) {\r\n      return { skillLevel: 'beginner', baseScore: 45, trend: 'improving' };\r\n    }\r\n\r\n    // Default profile\r\n    return {\r\n      skillLevel: 'intermediate',\r\n      baseScore: 70,\r\n      trend: 'stable'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate learning objectives based on game and mastery score\r\n   */\r\n  private generateLearningObjectives(gameId: GameType, masteryScore: number): string[] {\r\n    const objectiveMap: Record<GameType, string[]> = {\r\n      'numbers': ['Count 1-10', 'Number recognition', 'Basic arithmetic'],\r\n      'letters': ['Letter recognition', 'Letter sounds', 'Basic reading'],\r\n      'colors': ['Color identification', 'Color matching', 'Color mixing'],\r\n      'shapes': ['Shape recognition', 'Shape sorting', 'Pattern matching'],\r\n      'math': ['Addition', 'Subtraction', 'Problem solving'],\r\n      'patterns': ['Pattern recognition', 'Sequence completion'],\r\n      'rhyming': ['Rhyme identification', 'Sound patterns'],\r\n      'fill-in-the-blank': ['Reading comprehension', 'Vocabulary'],\r\n      'geography': ['Location awareness', 'Map reading'],\r\n      'alphabet-sequence': ['Alphabet order', 'Letter sequence'],\r\n      'number-sequence': ['Number order', 'Counting sequence']\r\n    };\r\n\r\n    const objectives = objectiveMap[gameId] || ['Basic skills'];\r\n    const masteryRatio = masteryScore / 100;\r\n    const achievedCount = Math.floor(objectives.length * masteryRatio);\r\n    \r\n    return objectives.slice(0, Math.max(1, achievedCount));\r\n  }\r\n\r\n  /**\r\n   * Generate demo sessions data for demo avatars\r\n   */\r\n  private generateDemoSessions(avatarId: string, limit?: number): GameSessionData[] {\r\n    const demoProfile = this.getDemoAvatarProfile(avatarId);\r\n    const gameTypes: GameType[] = ['numbers', 'letters', 'colors', 'shapes', 'math'];\r\n    const maxSessions = limit || 8; // Default to 8 sessions if no limit specified\r\n    \r\n    const sessions: GameSessionData[] = [];\r\n    \r\n    for (let i = 0; i < maxSessions; i++) {\r\n      const gameId = gameTypes[i % gameTypes.length];\r\n      const isCompleted = Math.random() > 0.2; // 80% completion rate\r\n      const questionsAttempted = 5 + Math.floor(Math.random() * 10); // 5-15 questions\r\n      const baseAccuracy = demoProfile.baseScore / 100;\r\n      const questionsCorrect = Math.floor(questionsAttempted * (baseAccuracy + (Math.random() - 0.5) * 0.3));\r\n      const sessionDuration = 60 + Math.random() * 240; // 1-5 minutes\r\n      \r\n      // Create session date (spread over last few weeks)\r\n      const sessionDate = new Date(Date.now() - (i * 2 * 24 * 60 * 60 * 1000)); // Every 2 days\r\n      \r\n      sessions.push({\r\n        id: `demo-session-${avatarId}-${i}`,\r\n        avatarId,\r\n        gameId,\r\n        sessionStart: sessionDate,\r\n        sessionEnd: isCompleted ? new Date(sessionDate.getTime() + sessionDuration * 1000) : undefined,\r\n        totalDuration: Math.floor(sessionDuration),\r\n        questionsAttempted,\r\n        questionsCorrect: Math.max(0, Math.min(questionsAttempted, questionsCorrect)),\r\n        completionStatus: isCompleted ? 'completed' : (Math.random() > 0.5 ? 'abandoned' : 'in_progress'),\r\n        difficultyLevel: demoProfile.skillLevel,\r\n        settingsUsed: {\r\n          difficulty: demoProfile.skillLevel,\r\n          hints_enabled: true,\r\n          sound_enabled: true\r\n        },\r\n        scoreData: {\r\n          finalScore: Math.round(baseAccuracy * 100 + (Math.random() - 0.5) * 20),\r\n          accuracy: questionsCorrect / questionsAttempted,\r\n          questionsCorrect,\r\n          questionsAttempted,\r\n          completionRate: isCompleted ? 1 : Math.random() * 0.8\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Sort by session start time (newest first)\r\n    return sessions.sort((a, b) => b.sessionStart.getTime() - a.sessionStart.getTime());\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const analyticsService = new SupabaseAnalyticsService(); "],"names":["SupabaseAnalyticsService","analyticsService","startGameSession","avatarId","gameType","settings","orgId","data","error","supabase","from","insert","avatar_id","org_id","game_type","settings_used","session_start","Date","toISOString","select","single","session","id","gameId","sessionStart","totalDuration","questionsAttempted","questionsCorrect","completionStatus","difficultyLevel","settingsUsed","sessionCache","set","eventSequenceCounters","trackEvent","sessionId","eventType","eventData","sequenceNumber","get","session_id","event_type","event_data","timestamp","sequence_number","updateSessionFromEvent","completeGameSession","finalScore","scoreData","accuracy","completionRate","cachedSession","Math","floor","getTime","update","session_end","total_duration","questions_attempted","questions_correct","completion_status","score_data","eq","duration","updateLearningProgress","delete","getAvatarProgress","logger","debug","shouldUseDatabase","info","generateDemoProgress","order","ascending","progressData","map","row","skillLevel","skill_level","masteryScore","mastery_score","learningObjectivesMet","learning_objectives_met","prerequisiteCompletion","prerequisite_completion","lastPlayed","last_played","totalSessions","total_sessions","averagePerformance","average_performance","improvementTrend","improvement_trend","length","getAvatarSessions","limit","generateDemoSessions","query","transformedData","undefined","sessionEnd","difficulty_level","getLearningPathRecommendations","maxRecommendations","progress","recommendations","availableGames","getAvailableGames","filter","game","slice","reason","priority","estimatedDifficulty","learningObjectives","prerequisitesMet","needsImprovement","p","sort","a","b","gameProgress","find","g","push","goodProgress","subjectsToExplore","Set","getGameSubject","subject","newGamesInSubject","some","playedGames","unplayedGames","has","subjectMap","getPerformanceMetrics","generateDemoMetrics","sessions","Promise","all","totalGamesPlayed","completedSessions","s","averageSessionDuration","reduce","sum","overallCompletionRate","skillLevelDistribution","dist","subjectPreferences","calculateSubjectPreferences","learningVelocity","calculateLearningVelocity","engagementScore","calculateEngagementScore","metrics","getAggregateAnalytics","sessionData","uniquePlayers","size","averageDuration","gameStats","stats","totalScore","popularGames","Object","entries","statData","avgScore","transformedSessions","learningEffectiveness","calculateLearningEffectivenessFromSessions","event","correct","newDifficulty","existingProgress","now","needs_realtime_update","previousAverage","newAverage","min","updated_at","calculateGameRecommendation","allProgress","checkPrerequisites","max","prerequisites","every","prereqId","prereqProgress","preferences","gameTypes","forEach","gameSessions","averageScore","score","oneWeekAgo","setDate","getDate","recentProgress","factors","sessionFrequency","consistency","sessionCount","avgDuration","recentSessions","recentCompletionRate","values","round","gameEffectiveness","effectiveness","keys","isDemoMode","process","env","NEXT_PUBLIC_DEMO_MODE","window","demoScenario","localStorage","getItem","isDemoAvatar","startsWith","demoProfile","getDemoAvatarProfile","index","baseScore","random","generateLearningObjectives","trend","includes","objectiveMap","objectives","masteryRatio","achievedCount","maxSessions","i","isCompleted","baseAccuracy","sessionDuration","sessionDate","difficulty","hints_enabled","sound_enabled","createClient","Map"],"mappings":"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"}