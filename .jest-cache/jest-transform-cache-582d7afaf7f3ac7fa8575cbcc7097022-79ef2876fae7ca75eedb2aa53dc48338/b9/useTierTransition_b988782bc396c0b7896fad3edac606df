4645762b24fd5a4b7a2bf5cdf2a585b6
/**
 * useTierTransition Hook
 * Provides tier transition functionality for subscription plan changes
 * Handles analysis, validation, and execution of tier changes
 */ 'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTierTransition", {
    enumerable: true,
    get: function() {
        return useTierTransition;
    }
});
const _react = require("react");
const _UserContext = require("../context/UserContext");
const _useSubscription = require("./useSubscription");
const _subscriptionService = require("../utils/subscriptionService");
const _client = require("../lib/supabase/client");
const _logger = require("../utils/logger");
function useTierTransition() {
    const { org } = (0, _UserContext.useUser)();
    const { subscriptionPlan, tier, currentUsage } = (0, _useSubscription.useSubscription)();
    const [isLoading, setIsLoading] = (0, _react.useState)(false);
    const [error, setError] = (0, _react.useState)(null);
    const supabase = (0, _client.createClient)();
    // Current tier and available transitions
    const currentTier = tier;
    const { upgrades: availableUpgrades, downgrades: availableDowngrades } = (0, _react.useMemo)(()=>{
        if (!currentTier) return {
            upgrades: [],
            downgrades: []
        };
        return _subscriptionService.SubscriptionService.getAvailableTransitions(currentTier);
    }, [
        currentTier
    ]);
    // Get current usage data
    const getCurrentUsageData = (0, _react.useCallback)(async ()=>{
        if (!org) {
            return {
                avatarsCount: 0,
                collectionsCount: 0,
                sessionsThisMonth: 0,
                dataRetentionMonths: 12
            };
        }
        try {
            // Get avatar count
            const { data: avatars } = await supabase.from('avatars').select('id').eq('org_id', org.id);
            // Get collections count (simplified - would normally be per-avatar)
            const { data: collections } = await supabase.from('game_collections').select('id').in('avatar_id', (avatars || []).map((a)=>a.id));
            // Get sessions this month
            const startOfMonth = new Date();
            startOfMonth.setDate(1);
            startOfMonth.setHours(0, 0, 0, 0);
            const { data: sessions } = await supabase.from('game_sessions').select('id').eq('org_id', org.id).gte('created_at', startOfMonth.toISOString());
            return {
                avatarsCount: avatars?.length || 0,
                collectionsCount: collections?.length || 0,
                sessionsThisMonth: sessions?.length || 0,
                dataRetentionMonths: 12 // Default
            };
        } catch (err) {
            _logger.logger.error('Failed to get usage data:', err);
            return {
                avatarsCount: currentUsage.avatarsCount,
                collectionsCount: 0,
                sessionsThisMonth: 0,
                dataRetentionMonths: 12
            };
        }
    }, [
        org,
        supabase,
        currentUsage.avatarsCount
    ]);
    // Utility functions - moved outside useCallback to avoid dependency issues
    const getTierDisplayName = (tier)=>{
        const tierNames = {
            personal: 'Personal Plan',
            professional: 'Professional Plan',
            enterprise: 'Enterprise Plan'
        };
        return tierNames[tier];
    };
    const getTierPrice = (tier)=>{
        const prices = {
            personal: 9.99,
            professional: 199.99,
            enterprise: 1499.99
        };
        return prices[tier];
    };
    // Analyze transition impact
    const analyzeTransition = (0, _react.useCallback)(async (targetTier)=>{
        if (!currentTier || !subscriptionPlan) {
            throw new Error('No current subscription to analyze');
        }
        setIsLoading(true);
        setError(null);
        try {
            const usageData = await getCurrentUsageData();
            // Get basic analysis
            const analysis = _subscriptionService.SubscriptionService.analyzeTierTransition(currentTier, targetTier, usageData);
            // Get cost information
            const currentCost = getTierPrice(subscriptionPlan.tier);
            const newCost = getTierPrice(targetTier);
            const monthlyDifference = newCost - currentCost;
            const proration = _subscriptionService.SubscriptionService.calculateProration(currentCost, newCost);
            return {
                fromTier: currentTier,
                toTier: targetTier,
                isUpgrade: analysis.isUpgrade,
                isDowngrade: analysis.isDowngrade,
                featureChanges: {
                    gained: analysis.featureChanges.gained,
                    lost: analysis.featureChanges.lost
                },
                usageImpact: {
                    overLimitItems: analysis.usageImpact.overLimitItems
                },
                costImpact: {
                    currentCost,
                    newCost,
                    monthlyDifference,
                    prorationAmount: proration.prorationAmount,
                    prorationDescription: proration.description
                },
                warnings: analysis.warnings,
                canTransition: analysis.canTransition
            };
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Failed to analyze transition';
            setError(message);
            throw err;
        } finally{
            setIsLoading(false);
        }
    }, [
        currentTier,
        subscriptionPlan,
        getCurrentUsageData
    ]);
    // Execute tier transition
    const executeTransition = (0, _react.useCallback)(async (targetTier)=>{
        if (!org || !currentTier) {
            throw new Error('No organization or current tier found');
        }
        setIsLoading(true);
        setError(null);
        try {
            // Validate transition first
            const usageData = await getCurrentUsageData();
            const validation = _subscriptionService.SubscriptionService.validateTierTransition(currentTier, targetTier, usageData);
            if (!validation.valid) {
                throw new Error(`Transition not allowed: ${validation.reasons.join(', ')}`);
            }
            // Get new subscription plan
            const { data: newPlan, error: planError } = await supabase.from('subscription_plans').select('*').eq('tier', targetTier).eq('active', true).order('base_price', {
                ascending: true
            }).limit(1).single();
            if (planError) throw planError;
            // Update organization subscription
            const { error: updateError } = await supabase.from('organizations').update({
                subscription_plan_id: newPlan.id,
                updated_at: new Date().toISOString()
            }).eq('id', org.id);
            if (updateError) throw updateError;
            // Log the transition
            _logger.logger.info('Tier transition completed:', {
                orgId: org.id,
                fromTier: currentTier,
                toTier: targetTier,
                timestamp: new Date().toISOString()
            });
            const tierDisplayName = getTierDisplayName(targetTier);
            const action = _subscriptionService.SubscriptionService.analyzeTierTransition(currentTier, targetTier, usageData).isUpgrade ? 'upgraded' : 'changed';
            return {
                success: true,
                message: `Successfully ${action} to ${tierDisplayName}!`
            };
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Failed to execute transition';
            setError(message);
            _logger.logger.error('Tier transition failed:', err);
            return {
                success: false,
                message
            };
        } finally{
            setIsLoading(false);
        }
    }, [
        org,
        currentTier,
        supabase,
        getCurrentUsageData
    ]);
    const validateTransition = (0, _react.useCallback)((targetTier)=>{
        if (!currentTier) {
            return {
                valid: false,
                reasons: [
                    'No current tier found'
                ]
            };
        }
        // Use current usage data synchronously (fallback values)
        const usageData = {
            avatarsCount: currentUsage.avatarsCount,
            collectionsCount: 0,
            sessionsThisMonth: 0,
            dataRetentionMonths: 12
        };
        return _subscriptionService.SubscriptionService.validateTierTransition(currentTier, targetTier, usageData);
    }, [
        currentTier,
        currentUsage.avatarsCount
    ]);
    const clearError = (0, _react.useCallback)(()=>{
        setError(null);
    }, []);
    return {
        // Current state
        currentTier,
        availableUpgrades,
        availableDowngrades,
        isLoading,
        error,
        // Analysis
        analyzeTransition,
        // Execution
        executeTransition,
        // Utilities
        getTierDisplayName,
        getTierPrice,
        validateTransition,
        // State management
        clearError
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxyZXBvc1xcZmFtaWx5LW9yaWVudGVkXFxzcmNcXGhvb2tzXFx1c2VUaWVyVHJhbnNpdGlvbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIHVzZVRpZXJUcmFuc2l0aW9uIEhvb2tcclxuICogUHJvdmlkZXMgdGllciB0cmFuc2l0aW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHN1YnNjcmlwdGlvbiBwbGFuIGNoYW5nZXNcclxuICogSGFuZGxlcyBhbmFseXNpcywgdmFsaWRhdGlvbiwgYW5kIGV4ZWN1dGlvbiBvZiB0aWVyIGNoYW5nZXNcclxuICovXHJcblxyXG4ndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVVzZXIgfSBmcm9tICdAL2NvbnRleHQvVXNlckNvbnRleHQnO1xyXG5pbXBvcnQgeyB1c2VTdWJzY3JpcHRpb24gfSBmcm9tICdAL2hvb2tzL3VzZVN1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IFxyXG4gIFN1YnNjcmlwdGlvblNlcnZpY2UsIFxyXG4gIHR5cGUgU3Vic2NyaXB0aW9uVGllcixcclxuICB0eXBlIFVzYWdlRGF0YSBcclxufSBmcm9tICdAL3V0aWxzL3N1YnNjcmlwdGlvblNlcnZpY2UnO1xyXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS9jbGllbnQnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRpZXJUcmFuc2l0aW9uQW5hbHlzaXMge1xyXG4gIGZyb21UaWVyOiBTdWJzY3JpcHRpb25UaWVyO1xyXG4gIHRvVGllcjogU3Vic2NyaXB0aW9uVGllcjtcclxuICBpc1VwZ3JhZGU6IGJvb2xlYW47XHJcbiAgaXNEb3duZ3JhZGU6IGJvb2xlYW47XHJcbiAgZmVhdHVyZUNoYW5nZXM6IHtcclxuICAgIGdhaW5lZDogc3RyaW5nW107XHJcbiAgICBsb3N0OiBzdHJpbmdbXTtcclxuICB9O1xyXG4gIHVzYWdlSW1wYWN0OiB7XHJcbiAgICBvdmVyTGltaXRJdGVtczogQXJyYXk8e1xyXG4gICAgICB0eXBlOiBzdHJpbmc7XHJcbiAgICAgIGN1cnJlbnQ6IG51bWJlcjtcclxuICAgICAgbmV3TGltaXQ6IG51bWJlcjtcclxuICAgICAgaW1wYWN0OiBzdHJpbmc7XHJcbiAgICB9PjtcclxuICB9O1xyXG4gIGNvc3RJbXBhY3Q6IHtcclxuICAgIGN1cnJlbnRDb3N0OiBudW1iZXI7XHJcbiAgICBuZXdDb3N0OiBudW1iZXI7XHJcbiAgICBtb250aGx5RGlmZmVyZW5jZTogbnVtYmVyO1xyXG4gICAgcHJvcmF0aW9uQW1vdW50OiBudW1iZXI7XHJcbiAgICBwcm9yYXRpb25EZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIH07XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG4gIGNhblRyYW5zaXRpb246IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGllclRyYW5zaXRpb25SZXR1cm4ge1xyXG4gIC8vIEN1cnJlbnQgc3RhdGVcclxuICBjdXJyZW50VGllcjogU3Vic2NyaXB0aW9uVGllciB8IG51bGw7XHJcbiAgYXZhaWxhYmxlVXBncmFkZXM6IFN1YnNjcmlwdGlvblRpZXJbXTtcclxuICBhdmFpbGFibGVEb3duZ3JhZGVzOiBTdWJzY3JpcHRpb25UaWVyW107XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIFxyXG4gIC8vIEFuYWx5c2lzXHJcbiAgYW5hbHl6ZVRyYW5zaXRpb246ICh0YXJnZXRUaWVyOiBTdWJzY3JpcHRpb25UaWVyKSA9PiBQcm9taXNlPFRpZXJUcmFuc2l0aW9uQW5hbHlzaXM+O1xyXG4gIFxyXG4gIC8vIEV4ZWN1dGlvblxyXG4gIGV4ZWN1dGVUcmFuc2l0aW9uOiAodGFyZ2V0VGllcjogU3Vic2NyaXB0aW9uVGllcikgPT4gUHJvbWlzZTx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIH0+O1xyXG4gIFxyXG4gIC8vIFV0aWxpdGllc1xyXG4gIGdldFRpZXJEaXNwbGF5TmFtZTogKHRpZXI6IFN1YnNjcmlwdGlvblRpZXIpID0+IHN0cmluZztcclxuICBnZXRUaWVyUHJpY2U6ICh0aWVyOiBTdWJzY3JpcHRpb25UaWVyKSA9PiBudW1iZXI7XHJcbiAgdmFsaWRhdGVUcmFuc2l0aW9uOiAodGFyZ2V0VGllcjogU3Vic2NyaXB0aW9uVGllcikgPT4geyB2YWxpZDogYm9vbGVhbjsgcmVhc29uczogc3RyaW5nW10gfTtcclxuICBcclxuICAvLyBTdGF0ZSBtYW5hZ2VtZW50XHJcbiAgY2xlYXJFcnJvcjogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1haW4gdGllciB0cmFuc2l0aW9uIGhvb2tcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaWVyVHJhbnNpdGlvbigpOiBVc2VUaWVyVHJhbnNpdGlvblJldHVybiB7XHJcbiAgY29uc3QgeyBvcmcgfSA9IHVzZVVzZXIoKTtcclxuICBjb25zdCB7IHN1YnNjcmlwdGlvblBsYW4sIHRpZXIsIGN1cnJlbnRVc2FnZSB9ID0gdXNlU3Vic2NyaXB0aW9uKCk7XHJcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIFxyXG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCk7XHJcblxyXG4gIC8vIEN1cnJlbnQgdGllciBhbmQgYXZhaWxhYmxlIHRyYW5zaXRpb25zXHJcbiAgY29uc3QgY3VycmVudFRpZXIgPSB0aWVyIGFzIFN1YnNjcmlwdGlvblRpZXIgfCBudWxsO1xyXG4gIGNvbnN0IHsgdXBncmFkZXM6IGF2YWlsYWJsZVVwZ3JhZGVzLCBkb3duZ3JhZGVzOiBhdmFpbGFibGVEb3duZ3JhZGVzIH0gPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGlmICghY3VycmVudFRpZXIpIHJldHVybiB7IHVwZ3JhZGVzOiBbXSwgZG93bmdyYWRlczogW10gfTtcclxuICAgIHJldHVybiBTdWJzY3JpcHRpb25TZXJ2aWNlLmdldEF2YWlsYWJsZVRyYW5zaXRpb25zKGN1cnJlbnRUaWVyKTtcclxuICB9LCBbY3VycmVudFRpZXJdKTtcclxuXHJcbiAgLy8gR2V0IGN1cnJlbnQgdXNhZ2UgZGF0YVxyXG4gIGNvbnN0IGdldEN1cnJlbnRVc2FnZURhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxVc2FnZURhdGE+ID0+IHtcclxuICAgIGlmICghb3JnKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYXZhdGFyc0NvdW50OiAwLFxyXG4gICAgICAgIGNvbGxlY3Rpb25zQ291bnQ6IDAsXHJcbiAgICAgICAgc2Vzc2lvbnNUaGlzTW9udGg6IDAsXHJcbiAgICAgICAgZGF0YVJldGVudGlvbk1vbnRoczogMTJcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgYXZhdGFyIGNvdW50XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXZhdGFycyB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYXZhdGFycycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxyXG4gICAgICAgIC5lcSgnb3JnX2lkJywgb3JnLmlkKTtcclxuXHJcbiAgICAgIC8vIEdldCBjb2xsZWN0aW9ucyBjb3VudCAoc2ltcGxpZmllZCAtIHdvdWxkIG5vcm1hbGx5IGJlIHBlci1hdmF0YXIpXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY29sbGVjdGlvbnMgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2dhbWVfY29sbGVjdGlvbnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcclxuICAgICAgICAuaW4oJ2F2YXRhcl9pZCcsIChhdmF0YXJzIHx8IFtdKS5tYXAoKGE6IHsgaWQ6IHN0cmluZyB9KSA9PiBhLmlkKSk7XHJcblxyXG4gICAgICAvLyBHZXQgc2Vzc2lvbnMgdGhpcyBtb250aFxyXG4gICAgICBjb25zdCBzdGFydE9mTW9udGggPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBzdGFydE9mTW9udGguc2V0RGF0ZSgxKTtcclxuICAgICAgc3RhcnRPZk1vbnRoLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG5cclxuICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9ucyB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZ2FtZV9zZXNzaW9ucycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxyXG4gICAgICAgIC5lcSgnb3JnX2lkJywgb3JnLmlkKVxyXG4gICAgICAgIC5ndGUoJ2NyZWF0ZWRfYXQnLCBzdGFydE9mTW9udGgudG9JU09TdHJpbmcoKSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGF2YXRhcnNDb3VudDogYXZhdGFycz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgICAgY29sbGVjdGlvbnNDb3VudDogY29sbGVjdGlvbnM/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICAgIHNlc3Npb25zVGhpc01vbnRoOiBzZXNzaW9ucz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgICAgZGF0YVJldGVudGlvbk1vbnRoczogMTIgLy8gRGVmYXVsdFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCB1c2FnZSBkYXRhOicsIGVycik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYXZhdGFyc0NvdW50OiBjdXJyZW50VXNhZ2UuYXZhdGFyc0NvdW50LFxyXG4gICAgICAgIGNvbGxlY3Rpb25zQ291bnQ6IDAsXHJcbiAgICAgICAgc2Vzc2lvbnNUaGlzTW9udGg6IDAsXHJcbiAgICAgICAgZGF0YVJldGVudGlvbk1vbnRoczogMTJcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LCBbb3JnLCBzdXBhYmFzZSwgY3VycmVudFVzYWdlLmF2YXRhcnNDb3VudF0pO1xyXG5cclxuICAvLyBVdGlsaXR5IGZ1bmN0aW9ucyAtIG1vdmVkIG91dHNpZGUgdXNlQ2FsbGJhY2sgdG8gYXZvaWQgZGVwZW5kZW5jeSBpc3N1ZXNcclxuICBjb25zdCBnZXRUaWVyRGlzcGxheU5hbWUgPSAodGllcjogU3Vic2NyaXB0aW9uVGllcik6IHN0cmluZyA9PiB7XHJcbiAgICBjb25zdCB0aWVyTmFtZXMgPSB7XHJcbiAgICAgIHBlcnNvbmFsOiAnUGVyc29uYWwgUGxhbicsXHJcbiAgICAgIHByb2Zlc3Npb25hbDogJ1Byb2Zlc3Npb25hbCBQbGFuJyxcclxuICAgICAgZW50ZXJwcmlzZTogJ0VudGVycHJpc2UgUGxhbidcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGllck5hbWVzW3RpZXJdO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldFRpZXJQcmljZSA9ICh0aWVyOiBTdWJzY3JpcHRpb25UaWVyKTogbnVtYmVyID0+IHtcclxuICAgIGNvbnN0IHByaWNlcyA9IHtcclxuICAgICAgcGVyc29uYWw6IDkuOTksXHJcbiAgICAgIHByb2Zlc3Npb25hbDogMTk5Ljk5LFxyXG4gICAgICBlbnRlcnByaXNlOiAxNDk5Ljk5XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHByaWNlc1t0aWVyXTtcclxuICB9O1xyXG5cclxuICAvLyBBbmFseXplIHRyYW5zaXRpb24gaW1wYWN0XHJcbiAgY29uc3QgYW5hbHl6ZVRyYW5zaXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAodGFyZ2V0VGllcjogU3Vic2NyaXB0aW9uVGllcik6IFByb21pc2U8VGllclRyYW5zaXRpb25BbmFseXNpcz4gPT4ge1xyXG4gICAgaWYgKCFjdXJyZW50VGllciB8fCAhc3Vic2NyaXB0aW9uUGxhbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1cnJlbnQgc3Vic2NyaXB0aW9uIHRvIGFuYWx5emUnKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1c2FnZURhdGEgPSBhd2FpdCBnZXRDdXJyZW50VXNhZ2VEYXRhKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgYmFzaWMgYW5hbHlzaXNcclxuICAgICAgY29uc3QgYW5hbHlzaXMgPSBTdWJzY3JpcHRpb25TZXJ2aWNlLmFuYWx5emVUaWVyVHJhbnNpdGlvbihjdXJyZW50VGllciwgdGFyZ2V0VGllciwgdXNhZ2VEYXRhKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBjb3N0IGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRDb3N0ID0gZ2V0VGllclByaWNlKHN1YnNjcmlwdGlvblBsYW4udGllciBhcyBTdWJzY3JpcHRpb25UaWVyKTtcclxuICAgICAgY29uc3QgbmV3Q29zdCA9IGdldFRpZXJQcmljZSh0YXJnZXRUaWVyKTtcclxuICAgICAgY29uc3QgbW9udGhseURpZmZlcmVuY2UgPSBuZXdDb3N0IC0gY3VycmVudENvc3Q7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBwcm9yYXRpb24gPSBTdWJzY3JpcHRpb25TZXJ2aWNlLmNhbGN1bGF0ZVByb3JhdGlvbihjdXJyZW50Q29zdCwgbmV3Q29zdCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21UaWVyOiBjdXJyZW50VGllcixcclxuICAgICAgICB0b1RpZXI6IHRhcmdldFRpZXIsXHJcbiAgICAgICAgaXNVcGdyYWRlOiBhbmFseXNpcy5pc1VwZ3JhZGUsXHJcbiAgICAgICAgaXNEb3duZ3JhZGU6IGFuYWx5c2lzLmlzRG93bmdyYWRlLFxyXG4gICAgICAgIGZlYXR1cmVDaGFuZ2VzOiB7XHJcbiAgICAgICAgICBnYWluZWQ6IGFuYWx5c2lzLmZlYXR1cmVDaGFuZ2VzLmdhaW5lZCxcclxuICAgICAgICAgIGxvc3Q6IGFuYWx5c2lzLmZlYXR1cmVDaGFuZ2VzLmxvc3RcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVzYWdlSW1wYWN0OiB7XHJcbiAgICAgICAgICBvdmVyTGltaXRJdGVtczogYW5hbHlzaXMudXNhZ2VJbXBhY3Qub3ZlckxpbWl0SXRlbXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvc3RJbXBhY3Q6IHtcclxuICAgICAgICAgIGN1cnJlbnRDb3N0LFxyXG4gICAgICAgICAgbmV3Q29zdCxcclxuICAgICAgICAgIG1vbnRobHlEaWZmZXJlbmNlLFxyXG4gICAgICAgICAgcHJvcmF0aW9uQW1vdW50OiBwcm9yYXRpb24ucHJvcmF0aW9uQW1vdW50LFxyXG4gICAgICAgICAgcHJvcmF0aW9uRGVzY3JpcHRpb246IHByb3JhdGlvbi5kZXNjcmlwdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybmluZ3M6IGFuYWx5c2lzLndhcm5pbmdzLFxyXG4gICAgICAgIGNhblRyYW5zaXRpb246IGFuYWx5c2lzLmNhblRyYW5zaXRpb25cclxuICAgICAgfTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGFuYWx5emUgdHJhbnNpdGlvbic7XHJcbiAgICAgIHNldEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtjdXJyZW50VGllciwgc3Vic2NyaXB0aW9uUGxhbiwgZ2V0Q3VycmVudFVzYWdlRGF0YV0pO1xyXG5cclxuICAvLyBFeGVjdXRlIHRpZXIgdHJhbnNpdGlvblxyXG4gIGNvbnN0IGV4ZWN1dGVUcmFuc2l0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRhcmdldFRpZXI6IFN1YnNjcmlwdGlvblRpZXIpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgfT4gPT4ge1xyXG4gICAgaWYgKCFvcmcgfHwgIWN1cnJlbnRUaWVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gb3JnYW5pemF0aW9uIG9yIGN1cnJlbnQgdGllciBmb3VuZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuICAgIHNldEVycm9yKG51bGwpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHRyYW5zaXRpb24gZmlyc3RcclxuICAgICAgY29uc3QgdXNhZ2VEYXRhID0gYXdhaXQgZ2V0Q3VycmVudFVzYWdlRGF0YSgpO1xyXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gU3Vic2NyaXB0aW9uU2VydmljZS52YWxpZGF0ZVRpZXJUcmFuc2l0aW9uKGN1cnJlbnRUaWVyLCB0YXJnZXRUaWVyLCB1c2FnZURhdGEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2l0aW9uIG5vdCBhbGxvd2VkOiAke3ZhbGlkYXRpb24ucmVhc29ucy5qb2luKCcsICcpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgbmV3IHN1YnNjcmlwdGlvbiBwbGFuXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogbmV3UGxhbiwgZXJyb3I6IHBsYW5FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc3Vic2NyaXB0aW9uX3BsYW5zJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ3RpZXInLCB0YXJnZXRUaWVyKVxyXG4gICAgICAgIC5lcSgnYWN0aXZlJywgdHJ1ZSlcclxuICAgICAgICAub3JkZXIoJ2Jhc2VfcHJpY2UnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG4gICAgICAgIC5saW1pdCgxKVxyXG4gICAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICAgIGlmIChwbGFuRXJyb3IpIHRocm93IHBsYW5FcnJvcjtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBvcmdhbml6YXRpb24gc3Vic2NyaXB0aW9uXHJcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdvcmdhbml6YXRpb25zJylcclxuICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbl9wbGFuX2lkOiBuZXdQbGFuLmlkLFxyXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZXEoJ2lkJywgb3JnLmlkKTtcclxuXHJcbiAgICAgIGlmICh1cGRhdGVFcnJvcikgdGhyb3cgdXBkYXRlRXJyb3I7XHJcblxyXG4gICAgICAvLyBMb2cgdGhlIHRyYW5zaXRpb25cclxuICAgICAgbG9nZ2VyLmluZm8oJ1RpZXIgdHJhbnNpdGlvbiBjb21wbGV0ZWQ6Jywge1xyXG4gICAgICAgIG9yZ0lkOiBvcmcuaWQsXHJcbiAgICAgICAgZnJvbVRpZXI6IGN1cnJlbnRUaWVyLFxyXG4gICAgICAgIHRvVGllcjogdGFyZ2V0VGllcixcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHRpZXJEaXNwbGF5TmFtZSA9IGdldFRpZXJEaXNwbGF5TmFtZSh0YXJnZXRUaWVyKTtcclxuICAgICAgY29uc3QgYWN0aW9uID0gU3Vic2NyaXB0aW9uU2VydmljZS5hbmFseXplVGllclRyYW5zaXRpb24oY3VycmVudFRpZXIsIHRhcmdldFRpZXIsIHVzYWdlRGF0YSkuaXNVcGdyYWRlIFxyXG4gICAgICAgID8gJ3VwZ3JhZGVkJyBcclxuICAgICAgICA6ICdjaGFuZ2VkJztcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICBtZXNzYWdlOiBgU3VjY2Vzc2Z1bGx5ICR7YWN0aW9ufSB0byAke3RpZXJEaXNwbGF5TmFtZX0hYFxyXG4gICAgICB9O1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZXhlY3V0ZSB0cmFuc2l0aW9uJztcclxuICAgICAgc2V0RXJyb3IobWVzc2FnZSk7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignVGllciB0cmFuc2l0aW9uIGZhaWxlZDonLCBlcnIpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlXHJcbiAgICAgIH07XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtvcmcsIGN1cnJlbnRUaWVyLCBzdXBhYmFzZSwgZ2V0Q3VycmVudFVzYWdlRGF0YV0pO1xyXG5cclxuICBjb25zdCB2YWxpZGF0ZVRyYW5zaXRpb24gPSB1c2VDYWxsYmFjaygodGFyZ2V0VGllcjogU3Vic2NyaXB0aW9uVGllcik6IHsgdmFsaWQ6IGJvb2xlYW47IHJlYXNvbnM6IHN0cmluZ1tdIH0gPT4ge1xyXG4gICAgaWYgKCFjdXJyZW50VGllcikge1xyXG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIHJlYXNvbnM6IFsnTm8gY3VycmVudCB0aWVyIGZvdW5kJ10gfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVc2UgY3VycmVudCB1c2FnZSBkYXRhIHN5bmNocm9ub3VzbHkgKGZhbGxiYWNrIHZhbHVlcylcclxuICAgIGNvbnN0IHVzYWdlRGF0YTogVXNhZ2VEYXRhID0ge1xyXG4gICAgICBhdmF0YXJzQ291bnQ6IGN1cnJlbnRVc2FnZS5hdmF0YXJzQ291bnQsXHJcbiAgICAgIGNvbGxlY3Rpb25zQ291bnQ6IDAsIC8vIFdvdWxkIG5lZWQgdG8gZmV0Y2ggdGhpc1xyXG4gICAgICBzZXNzaW9uc1RoaXNNb250aDogMCwgLy8gV291bGQgbmVlZCB0byBmZXRjaCB0aGlzXHJcbiAgICAgIGRhdGFSZXRlbnRpb25Nb250aHM6IDEyXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBTdWJzY3JpcHRpb25TZXJ2aWNlLnZhbGlkYXRlVGllclRyYW5zaXRpb24oY3VycmVudFRpZXIsIHRhcmdldFRpZXIsIHVzYWdlRGF0YSk7XHJcbiAgfSwgW2N1cnJlbnRUaWVyLCBjdXJyZW50VXNhZ2UuYXZhdGFyc0NvdW50XSk7XHJcblxyXG4gIGNvbnN0IGNsZWFyRXJyb3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAvLyBDdXJyZW50IHN0YXRlXHJcbiAgICBjdXJyZW50VGllcixcclxuICAgIGF2YWlsYWJsZVVwZ3JhZGVzLFxyXG4gICAgYXZhaWxhYmxlRG93bmdyYWRlcyxcclxuICAgIGlzTG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgXHJcbiAgICAvLyBBbmFseXNpc1xyXG4gICAgYW5hbHl6ZVRyYW5zaXRpb24sXHJcbiAgICBcclxuICAgIC8vIEV4ZWN1dGlvblxyXG4gICAgZXhlY3V0ZVRyYW5zaXRpb24sXHJcbiAgICBcclxuICAgIC8vIFV0aWxpdGllc1xyXG4gICAgZ2V0VGllckRpc3BsYXlOYW1lLFxyXG4gICAgZ2V0VGllclByaWNlLFxyXG4gICAgdmFsaWRhdGVUcmFuc2l0aW9uLFxyXG4gICAgXHJcbiAgICAvLyBTdGF0ZSBtYW5hZ2VtZW50XHJcbiAgICBjbGVhckVycm9yXHJcbiAgfTtcclxufSAiXSwibmFtZXMiOlsidXNlVGllclRyYW5zaXRpb24iLCJvcmciLCJ1c2VVc2VyIiwic3Vic2NyaXB0aW9uUGxhbiIsInRpZXIiLCJjdXJyZW50VXNhZ2UiLCJ1c2VTdWJzY3JpcHRpb24iLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJ1c2VTdGF0ZSIsImVycm9yIiwic2V0RXJyb3IiLCJzdXBhYmFzZSIsImNyZWF0ZUNsaWVudCIsImN1cnJlbnRUaWVyIiwidXBncmFkZXMiLCJhdmFpbGFibGVVcGdyYWRlcyIsImRvd25ncmFkZXMiLCJhdmFpbGFibGVEb3duZ3JhZGVzIiwidXNlTWVtbyIsIlN1YnNjcmlwdGlvblNlcnZpY2UiLCJnZXRBdmFpbGFibGVUcmFuc2l0aW9ucyIsImdldEN1cnJlbnRVc2FnZURhdGEiLCJ1c2VDYWxsYmFjayIsImF2YXRhcnNDb3VudCIsImNvbGxlY3Rpb25zQ291bnQiLCJzZXNzaW9uc1RoaXNNb250aCIsImRhdGFSZXRlbnRpb25Nb250aHMiLCJkYXRhIiwiYXZhdGFycyIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwiY29sbGVjdGlvbnMiLCJpbiIsIm1hcCIsImEiLCJzdGFydE9mTW9udGgiLCJEYXRlIiwic2V0RGF0ZSIsInNldEhvdXJzIiwic2Vzc2lvbnMiLCJndGUiLCJ0b0lTT1N0cmluZyIsImxlbmd0aCIsImVyciIsImxvZ2dlciIsImdldFRpZXJEaXNwbGF5TmFtZSIsInRpZXJOYW1lcyIsInBlcnNvbmFsIiwicHJvZmVzc2lvbmFsIiwiZW50ZXJwcmlzZSIsImdldFRpZXJQcmljZSIsInByaWNlcyIsImFuYWx5emVUcmFuc2l0aW9uIiwidGFyZ2V0VGllciIsIkVycm9yIiwidXNhZ2VEYXRhIiwiYW5hbHlzaXMiLCJhbmFseXplVGllclRyYW5zaXRpb24iLCJjdXJyZW50Q29zdCIsIm5ld0Nvc3QiLCJtb250aGx5RGlmZmVyZW5jZSIsInByb3JhdGlvbiIsImNhbGN1bGF0ZVByb3JhdGlvbiIsImZyb21UaWVyIiwidG9UaWVyIiwiaXNVcGdyYWRlIiwiaXNEb3duZ3JhZGUiLCJmZWF0dXJlQ2hhbmdlcyIsImdhaW5lZCIsImxvc3QiLCJ1c2FnZUltcGFjdCIsIm92ZXJMaW1pdEl0ZW1zIiwiY29zdEltcGFjdCIsInByb3JhdGlvbkFtb3VudCIsInByb3JhdGlvbkRlc2NyaXB0aW9uIiwiZGVzY3JpcHRpb24iLCJ3YXJuaW5ncyIsImNhblRyYW5zaXRpb24iLCJtZXNzYWdlIiwiZXhlY3V0ZVRyYW5zaXRpb24iLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVUaWVyVHJhbnNpdGlvbiIsInZhbGlkIiwicmVhc29ucyIsImpvaW4iLCJuZXdQbGFuIiwicGxhbkVycm9yIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsaW1pdCIsInNpbmdsZSIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwic3Vic2NyaXB0aW9uX3BsYW5faWQiLCJ1cGRhdGVkX2F0IiwiaW5mbyIsIm9yZ0lkIiwidGltZXN0YW1wIiwidGllckRpc3BsYXlOYW1lIiwiYWN0aW9uIiwic3VjY2VzcyIsInZhbGlkYXRlVHJhbnNpdGlvbiIsImNsZWFyRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FFRDs7Ozs7K0JBc0VnQkE7OztlQUFBQTs7O3VCQXBFK0I7NkJBQ3ZCO2lDQUNRO3FDQUt6Qjt3QkFDc0I7d0JBQ047QUEyRGhCLFNBQVNBO0lBQ2QsTUFBTSxFQUFFQyxHQUFHLEVBQUUsR0FBR0MsSUFBQUEsb0JBQU87SUFDdkIsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRUMsSUFBSSxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsSUFBQUEsZ0NBQWU7SUFDaEUsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdDLElBQUFBLGVBQVEsRUFBQztJQUMzQyxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR0YsSUFBQUEsZUFBUSxFQUFnQjtJQUVsRCxNQUFNRyxXQUFXQyxJQUFBQSxvQkFBWTtJQUU3Qix5Q0FBeUM7SUFDekMsTUFBTUMsY0FBY1Y7SUFDcEIsTUFBTSxFQUFFVyxVQUFVQyxpQkFBaUIsRUFBRUMsWUFB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